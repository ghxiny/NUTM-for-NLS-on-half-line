(* ::Package:: *)

(************************************************************************)
(* This file was generated automatically by the Mathematica front end.  *)
(* It contains Initialization cells from a Notebook file, which         *)
(* typically will have the same name as this file except ending in      *)
(* ".nb" instead of ".m".                                               *)
(*                                                                      *)
(* This file is intended to be loaded into the Mathematica kernel using *)
(* the package loading commands Get or Needs.  Doing so is equivalent   *)
(* to using the Evaluate Initialization Cells menu command in the front *)
(* end.                                                                 *)
(*                                                                      *)
(* DO NOT EDIT THIS FILE.  This entire file is regenerated              *)
(* automatically each time the parent Notebook file is saved in the     *)
(* Mathematica front end.  Any changes you make to this file will be    *)
(* overwritten.                                                         *)
(************************************************************************)



(* ::Input::Initialization:: *)
Needs["RiemannHilbert`"];
HillNLS::usage="HillNLS[q,n] gives the eigenvalues of the modified Zakharov-Shabat scattering (including continuous spectrum) problem with n Fourier modes using Hill's method.";
LocatePolesNLS::usage="LocatePoles[q,n] gives the true eigenvalues of the modified Zakharov-Shabat scattering problem.";
NLS::usage="NLS[i][x,t] = {out,\[CapitalPhi],rhp1,rhp2,timestring} where out is the solution of NLS, \[CapitalPhi] is the solution of the Riemann-Hilbert problem, rhp1 and rhp2 are the Riemann-Hilbert problems and timestring is the string of computation times.  This is done using the deformation in Region i.";
NLSAuto::usage="NLSAuto[x,t] returns the solution of the NLS equation with deformation selected automagically.  Many things must be initialized.  Sample code:

	q[x_]:=.1 Exp[-x^2+I x];\[IndentingNewLine]Defocusing[];
	H=ScatteringMatrixFiniteNLS[q,50,6];\[IndentingNewLine]aa//Clear;bb//Clear;\[IndentingNewLine]aa[k_]:=aa[k]=H[k][[1,1]];\[IndentingNewLine]bb[k_]:=bb[k]=H[k][[2,1]];
	SetParams[.6,.1,10.^(-9),15,30];\[IndentingNewLine]h[k_]:=3/(1+Abs[k/2+1/3.2]^8);\[IndentingNewLine]Setrsamp[h];\[IndentingNewLine]Settimeflag[False];\[IndentingNewLine]\[Nu]=Getnu[];\[IndentingNewLine]\[Rho][k_]:=bb[k]/aa[k];
	up=I(\[Nu]+.0001);m=40;el=8;\[IndentingNewLine]f={Fun[\[Rho],Line[{-el,0}-up],m],Fun[\[Rho],Line[{0,el}-up],m],Fun[\[Rho],Line[{el,0}+up],m],Fun[\[Rho],Line[{0,-el}+up],m]};

	up=I(\[Nu]+.0001);m=40;el=8;\[IndentingNewLine]f={Fun[\[Rho],Line[{-el,0}-up],m],Fun[\[Rho],Line[{0,el}-up],m],Fun[\[Rho],Line[{el,0}+up],m],Fun[\[Rho],Line[{0,-el}+up],m]};
SetScatteringData[aa,bb,m\[Rho],LocatePoles[q,40]]"
Focusing::usage="Focusing[], switch to focusing NLS";
Defocusing::usage="Defocusing[], switch to focusing NLS";
SetScatteringData::usage="SetScatteringData[a,b,\[Rho],poles] or SetScatteringData[a,b,\[Rho],poles,normingConstants] sets the scattering data for the NLS equation";
SetParams::usage="SetParams[\[Nu],rad,globalTol,smallN,bigN] sets the parameters for the rest of the code:
	\[Nu]: half of width of strip of analyticity
	rad: radius of soliton contours
	globalTol: contour truncation tolerance
	smallN: small number of collocation points
	bigN: big number of collocation points";
GetScatteringData::usage="GetScatteringData[] = {\[Rho],poles,normingConstants}";
ScatteringMatrixFiniteNLS::usage="ScatteringMatrixFiniteNLS[q,n,L] returns a function f[w] that produces an approximation of the scattering matrix at w. The parameter n indicates the number of collocation points and L sets the problem on [-L,L]
Sample code:
	q[x_]:=.1 Exp[-x^2+I x];\[IndentingNewLine]Defocusing[];
	H=ScatteringMatrixFiniteNLS[q,50,6];\[IndentingNewLine]aa//Clear;bb//Clear;\[IndentingNewLine]aa[k_]:=aa[k]=H[k][[1,1]];\[IndentingNewLine]bb[k_]:=bb[k]=H[k][[2,1]];
";
Getnu::usage="Getnu[] returns \[Nu]";
Setrsamp::usage="Setrsamp[h] sets a function that should be chosen so that that |\[Rho]| < h";
timestring::usage="A string updated by NLS[i][x,t]
(x,t) 1) Construct: --time to construct rhp1-- 1) Solve: --time to solve rhp1-- 2) Construct: --time to construct rhp2-- 2) Solve: --time to solve rhp2--";
Settimeflag::usage="Settimeflag[bool] bool = True forces timestring to be printed each time NLS[i][x,t] is called";
startift;
domainOutput;
ift;
\[CapitalPhi]t;
dom;
Jadapt;J;Jsamp;
L;U;DD;G2;
rhp1;
Begin["Private`"];


(* ::Input::Initialization:: *)
Focusing[]:=Module[{},\[Lambda]=1];
Defocusing[]:=Module[{},\[Lambda]=-1];
(*SetScatteringData[aa_,bb_,rr_,ma_,mc_]:=Module[{},
r[k_]:=rr[k];
a=ma;
\[Tau][k_]:=1+\[Lambda] r[k]cc[r[cc[k]]];
\[Tau][_?InfinityQ]:=1;
\[Tau][k_List]:=\[Tau]/@k;
dom=Truncate[globalTol][{Log[\[Tau][#]]&,Line[{-el,el}],100}][[1]];
Print[dom];
c=mc;
];*)
SetScatteringData[aa_,bb_,rr_,ma_]:=Module[{},
r[k_]:=rr[k];
a=ma;
a1=aa;
b1=bb;
(*\[Tau][k_]:=1+\[Lambda] r[k]cc[r[cc[k]]];
\[Tau][_?InfinityQ]:=1;
\[Tau][k_List]:=\[Tau]/@k;need this for poles but tao is used for other names now*)
c={};
If[ma!= {},
dom=Truncate[globalTol][{Log[\[Tau][#]]&,Line[{-el,el}],100}][[1]];
Print[dom];
df1=f1';
da[k_]:=Cauchy[df1,k];
c={};
For[i=1,i<=Length[ma],i++,
c=Join[c,{Quiet[bb[ma[[i]]]]/da[ma[[i]]]}];(*compute norming constants*)
];
];
];
SetParams[nu_,rad1_,tol_,sN_,bN_]:=Module[{},
\[Nu]=nu; (*parameter for width of strip of analyticity*)
rad=rad1;
globalTol=tol;
smallN=sN;
bigN=bN;
];
GetScatteringData[]:=Module[{},{r,a,c}];
Getnu[]:=\[Nu];
Setrsamp[h_]:=Module[{},rsamp=h];
Settimeflag[h_]:=Module[{},timeflag=h];
SetN[x_]:=Module[{},bigN=x[[1]];smallN=x[[2]];];
expconst=1;
el=20;
bigN=20;
smallN=10;


(* ::Input::Initialization:: *)
delta0[k_]:=a1[k]*Conjugate[a1[-Conjugate[k]]]-\[Lambda]*Conjugate[b1[-Conjugate[k]]]*b1[k];(*the sign before lambda is diff in dirib*)
gam[k_]:=b1[k]/Conjugate[a1[Conjugate[k]]];
Gam[k_]:=(-1)*(-\[Lambda])*Conjugate[b1[-Conjugate[k]]]/a1[k]/delta0[k];(*the fisrt sign is diff in dirib*)
\[Theta][x_,t_][z_]:=2 I (2 t z^2+x z);
(*G1[x_,t_][z_]:=Inverse[(1	0
Gam[z]*Exp[\[Theta][x,t][z]]	1

)];*)
G1[x_,t_][z_]:=({
 {1, 0},
 {-Gam[z]*Exp[\[Theta][x,t][z]], 1}
});
G1[_,_][_?InfinityQ]:=({
 {1., 0},
 {0, 1.}
});
(*G3[x_,t_][z_]:=Inverse[(1	\[Lambda]*Conjugate[Gam[Conjugate[z]]]*Exp[-\[Theta][x,t][z]]
0	1

)];*)
G3[x_,t_][z_]:=({
 {1, -\[Lambda]*Conjugate[Gam[Conjugate[z]]]*Exp[-\[Theta][x,t][z]]},
 {0, 1}
});
G3[_,_][_?InfinityQ]:=({
 {1., 0},
 {0, 1.}
});
(*G4[x_,t_][z_]:=Inverse[(1	-gam[z]*Exp[-\[Theta][x,t][z]]
-\[Lambda]*Conjugate[gam[z]]*Exp[\[Theta][x,t][z]]	1+\[Lambda]*Abs[gam[z]]^2

)];*)
G4[x_,t_][z_]:=({
 {1+\[Lambda]*Conjugate[gam[Conjugate[z]]]*gam[z], gam[z]*Exp[-\[Theta][x,t][z]]},
 {\[Lambda]*Conjugate[gam[Conjugate[z]]]*Exp[\[Theta][x,t][z]], 1}
});
G4[_,_][_?InfinityQ]:=({
 {1., 0},
 {0, 1.}
});
(*G2[x_,t_][z_]:=G3[x,t][z].Inverse[G4[x,t][z]].G1[x,t][z];  (*wrong*)*) 
(*G2[x_,t_][z_]:=G1[x,t][z].Inverse[G4[x,t][z]].G3[x,t][z];  (*mine*)*)
G2[x_,t_][z_]:=\!\(\*
TagBox[
RowBox[{"(", "", GridBox[{
{"1", 
RowBox[{
RowBox[{"-", 
SuperscriptBox["E", 
RowBox[{"-", 
RowBox[{
RowBox[{"\[Theta]", "[", 
RowBox[{"x", ",", "t"}], "]"}], "[", "z", "]"}]}]]}], " ", 
RowBox[{"(", 
RowBox[{
RowBox[{"\[Lambda]", " ", 
RowBox[{"Conjugate", "[", 
RowBox[{"Gam", "[", 
RowBox[{"Conjugate", "[", "z", "]"}], "]"}], "]"}]}], "+", 
RowBox[{"gam", "[", "z", "]"}]}], ")"}]}]},
{
RowBox[{
RowBox[{"-", 
SuperscriptBox["E", 
RowBox[{
RowBox[{"\[Theta]", "[", 
RowBox[{"x", ",", "t"}], "]"}], "[", "z", "]"}]]}], " ", 
RowBox[{"(", 
RowBox[{
RowBox[{"\[Lambda]", " ", 
RowBox[{"Conjugate", "[", 
RowBox[{"gam", "[", 
RowBox[{"Conjugate", "[", "z", "]"}], "]"}], "]"}]}], "+", 
RowBox[{"Gam", "[", "z", "]"}]}], ")"}]}], 
RowBox[{"1", "+", 
RowBox[{
RowBox[{"(", 
RowBox[{
RowBox[{"\[Lambda]", " ", 
RowBox[{"Conjugate", "[", 
RowBox[{"Gam", "[", 
RowBox[{"Conjugate", "[", "z", "]"}], "]"}], "]"}]}], "+", 
RowBox[{"gam", "[", "z", "]"}]}], ")"}], "*", 
RowBox[{"(", 
RowBox[{
RowBox[{"\[Lambda]", " ", 
RowBox[{"Conjugate", "[", 
RowBox[{"gam", "[", 
RowBox[{"Conjugate", "[", "z", "]"}], "]"}], "]"}]}], "+", 
RowBox[{"Gam", "[", "z", "]"}]}], ")"}]}]}]}
},
GridBoxAlignment->{"Columns" -> {{Center}}, "ColumnsIndexed" -> {}, "Rows" -> {{Baseline}}, "RowsIndexed" -> {}, "Items" -> {}, "ItemsIndexed" -> {}},
GridBoxSpacings->{"Columns" -> {Offset[0.27999999999999997`], {Offset[0.7]}, Offset[0.27999999999999997`]}, "ColumnsIndexed" -> {}, "Rows" -> {Offset[0.2], {Offset[0.4]}, Offset[0.2]}, "RowsIndexed" -> {}, "Items" -> {}, "ItemsIndexed" -> {}}], "", ")"}],
Function[BoxForm`e$, MatrixForm[BoxForm`e$]]]\);
G2[_,_][_?InfinityQ]:=({
 {1., 0},
 {0, 1.}
});
(**)
Gamsamp[z_]:=rsamp[z];
gamsamp[z_]:=rsamp[z];
G1samp[x_,t_][z_]:=Inverse[({
 {1, 0},
 {Gamsamp[z]*Abs[Exp[\[Theta][x,t][z]]], 1}
})];
G1samp[_,_][_?InfinityQ]:=({
 {1., 0},
 {0, 1.}
});
G3samp[x_,t_][z_]:=Inverse[({
 {1, \[Lambda]*Conjugate[Gamsamp[Conjugate[z]]]*Abs[Exp[-\[Theta][x,t][z]]]},
 {0, 1}
})];
G3samp[_,_][_?InfinityQ]:=({
 {1., 0},
 {0, 1.}
});
G4samp[x_,t_][z_]:=Inverse[({
 {1, gamsamp[z]*Abs[Exp[-\[Theta][x,t][z]]]},
 {Conjugate[gamsamp[Conjugate[z]]]*Abs[Exp[\[Theta][x,t][z]]], 1+\[Lambda]*gamsamp[z]*Conjugate[gamsamp[Conjugate[z]]]}
})];
G4samp[_,_][_?InfinityQ]:=({
 {1., 0},
 {0, 1.}
});
G2samp[x_,t_][z_]:=G1samp[x,t][z].Inverse[G4samp[x,t][z]].G3samp[x,t][z];  (*mine*)
G2samp[_,_][_?InfinityQ]:=({
 {1., 0},
 {0, 1.}
});
(**)
(*deform g4*)
M[x_,t_][z_]:=({
 {1, gam[z]*Exp[-\[Theta][x,t][z]]},
 {0, 1}
});
(*Mn[x_,t_][k_]:=(1	rb[k] Exp[-\[Theta][x,t][k]]
0	1

);*)
Msamp[x_,t_][z_]:=({
 {1, gamsamp[z] Exp[-\[Theta][x,t][z]]},
 {0, 1}
});
P[x_,t_][z_]:=({
 {1, 0},
 {\[Lambda]*Conjugate[gam[Conjugate[z]]]*Exp[\[Theta][x,t][z]], 1}
});
(*Pn[x_,t_][k_]:=(1	0
r[k] Exp[\[Theta][x,t][k]]	1

);*)
Psamp[x_,t_][z_]:=({
 {1, 0},
 {\[Lambda]*Conjugate[gamsamp[Conjugate[z]]]*Exp[\[Theta][x,t][z]], 1}
});
(**)

(*deform g2*)
\[Tau][z_]:=1+(\[Lambda] Conjugate[Gam[Conjugate[z]]]+gam[z])*(\[Lambda] Conjugate[gam[Conjugate[z]]]+Gam[z]);
\[Tau]samp[z_]:=1+(Abs[\[Lambda] Conjugate[Gamsamp[Conjugate[z]]]]+Abs[gamsamp[z]])*(Abs[\[Lambda] Conjugate[gamsamp[Conjugate[z]]]]+Abs[Gamsamp[z]]);

L[x_,t_][z_]:=({
 {1, 0},
 {-((\[Lambda] Conjugate[gam[Conjugate[z]]]+Gam[z]))/\[Tau][z]*Exp[\[Theta][x,t][z]], 1}
});
Lsamp[x_,t_][z_]:=({
 {1, 0},
 {-((Abs[\[Lambda] Conjugate[gamsamp[Conjugate[z]]]]+Abs[Gamsamp[z]]))/\[Tau]samp[z]*Exp[\[Theta][x,t][z]], 1}
});
U[x_,t_][z_]:=({
 {1, -(\[Lambda] Conjugate[Gam[Conjugate[z]]]+gam[z])/\[Tau][z]*Exp[-\[Theta][x,t][z]]},
 {0, 1}
});
Usamp[x_,t_][z_]:=({
 {1, -(Abs[\[Lambda] Conjugate[Gamsamp[Conjugate[z]]]]+Abs[gamsamp[z]])/\[Tau]samp[z]*Exp[-\[Theta][x,t][z]]},
 {0, 1}
});
DD[z_]:=({
 {1/\[Tau][z], 0},
 {0, \[Tau][z]}
});
DDsamp[z_]:=({
 {1/\[Tau]samp[z], 0},
 {0, \[Tau]samp[z]}
});
(**)
rb[k_]:=\[Lambda] cc[r[cc[k]]];
rbsamp[k_]:=\[Lambda] cc[rsamp[cc[k]]];

Ln[x_,t_][k_]:=({
 {1, 0},
 {r[k]/\[Tau][k] Exp[\[Theta][x,t][k]], 1}
});
Lnsamp[x_,t_][k_]:=({
 {1, 0},
 {rsamp[k]/\[Tau]samp[k] Exp[\[Theta][x,t][k]], 1}
});

Linn[x_,t_][k_]:=({
 {1, 0},
 {-(r[k]/\[Tau][k])Exp[\[Theta][x,t][k]], 1}
});
Linnsamp[x_,t_][k_]:=({
 {1, 0},
 {-(rsamp[k]/\[Tau]samp[k])Exp[\[Theta][x,t][k]], 1}
});


Un[x_,t_][k_]:=({
 {1, rb[k]/\[Tau][k] Exp[-\[Theta][x,t][k]]},
 {0, 1}
});
Unsamp[x_,t_][k_]:=({
 {1, rbsamp[k]/\[Tau]samp[k] Exp[-\[Theta][x,t][k]]},
 {0, 1}
});

DDn[k_]:=({
 {\[Tau][k], 0},
 {0, 1/\[Tau][k]}
});

DDnsamp[k_]:=({
 {\[Tau]samp[k], 0},
 {0, 1/\[Tau]samp[k]}
});

G[x_,t_][z_]:=({
 {1+r[z]rb[z], rb[z]Exp[-2 I (2 t z^2+x z)]},
 {r[z] Exp[2 I (2 t z^2+ x z)], 1}
});
G[_,_][_?InfinityQ]:=({
 {1., 0},
 {0, 1.}
});
Gsamp[x_,t_][z_]:=({
 {1+rsamp[z]rbsamp[z], rbsamp[z]Exp[-2 I (2 t z^2+x z)]},
 {rsamp[z] Exp[2 I (2 t z^2+ x z)], 1}
});
Gsamp[_,_][_?InfinityQ]:=({
 {1., 0},
 {0, 1.}
});



qn[x_,t_][k_]:=Module[{out,i},
out = 1;
For[i=1,i<=Length[a],i++,
If[Abs[c[[i]]]Exp[Re[\[Theta][x,t][a[[i]]]]]>expconst,
out = out*(k-a[[i]])/(k-Conjugate[a[[i]]]);
];
];
out];
Qn[x_,t_][k_]:=({
 {qn[x,t][k], 0},
 {0, 1/qn[x,t][k]}
});
Qn[x_,t_][_?InfinityQ]:=({
 {1., 0},
 {0, 1.}
});


(*\[CapitalPhi]s[x_,t_][z_]:=\[CapitalPhi][z/Sqrt[t]-x/(4 t)];
\[CapitalPhi]ins[x_,t_][z_]:=\[CapitalPhi]in[z/Sqrt[t]-x/(4 t)]
rs[x_,t_][z_]:=r[z/Sqrt[t]-x/(4 t)];
\[Tau]s[x_,t_][z_]:=\[Tau][z/Sqrt[t]-x/(4 t)];
rsb[x_,t_][z_]:=rb[z/Sqrt[t]-x/(4 t)];

\[CapitalPhi]ssamp[x_,t_][z_]:=\[CapitalPhi]samp[z/Sqrt[t]-x/(4 t)];
\[CapitalPhi]inssamp[x_,t_][z_]:=\[CapitalPhi]insamp[z/Sqrt[t]-x/(4 t)]
rssamp[x_,t_][z_]:=rsamp[z/Sqrt[t]-x/(4 t)];
\[Tau]ssamp[x_,t_][z_]:=\[Tau]samp[z/Sqrt[t]-x/(4 t)];
rsbsamp[x_,t_][z_]:=rbsamp[z/Sqrt[t]-x/(4 t)];
\[Theta]s[x_,t_][z_]:=-(\[ImaginaryI] x^2)/(4 t)+4 \[ImaginaryI] z^2

L[x_,t_][k_]:=(1	0
rs[x,t][k]/\[Tau]s[x,t][k]Exp[\[Theta]s[x,t][k]]	1

);
Lsamp[x_,t_][k_]:=(1	0
rssamp[x,t][k]/\[Tau]ssamp[x,t][k]Exp[\[Theta]s[x,t][k]]	1

);

Lin[x_,t_][k_]:=(1	0
-rs[x,t][k]/\[Tau]s[x,t][k]Exp[\[Theta]s[x,t][k]]	1

);
Linsamp[x_,t_][k_]:=(1	0
-rssamp[x,t][k]/\[Tau]ssamp[x,t][k]Exp[\[Theta]s[x,t][k]]	1

);

U[x_,t_][k_]:=(1	rsb[x,t][k]/\[Tau]s[x,t][k]Exp[-\[Theta]s[x,t][k]]
0	1

);
Usamp[x_,t_][k_]:=(1	rsbsamp[x,t][k]/\[Tau]ssamp[x,t][k]Exp[-\[Theta]s[x,t][k]]
0	1

);

Uin[x_,t_][k_]:=(1	-rsb[x,t][k]/\[Tau]s[x,t][k]Exp[-\[Theta]s[x,t][k]]
0	1

);
Uinsamp[x_,t_][k_]:=(1	-rsbsamp[x,t][k]/\[Tau]ssamp[x,t][k]Exp[-\[Theta]s[x,t][k]]
0	1

);

M[x_,t_][k_]:=(1	rsb[x,t][k] Exp[-\[Theta]s[x,t][k]]
0	1

);
Msamp[x_,t_][k_]:=(1	rsbsamp[x,t][k] Exp[-\[Theta]s[x,t][k]]
0	1

);

Mi[x_,t_][k_]:=(1	-rsb[x,t][k] Exp[-\[Theta]s[x,t][k]]
0	1

);
Misamp[x_,t_][k_]:=(1	-rsbsamp[x,t][k] Exp[-\[Theta]s[x,t][k]]
0	1

);

P[x_,t_][k_]:=(1	0
rs[x,t][k] Exp[\[Theta]s[x,t][k]]	1

);
Psamp[x_,t_][k_]:=(1	0
rssamp[x,t][k] Exp[\[Theta]s[x,t][k]]	1

);

Pin[x_,t_][k_]:=(1	0
-rs[x,t][k] Exp[\[Theta]s[x,t][k]]	1

);
Pinsamp[x_,t_][k_]:=(1	0
-rssamp[x,t][k] Exp[\[Theta]s[x,t][k]]	1

);


DD[x_,t_][k_]:=(\[Tau]s[x,t][k]	0
0	1/\[Tau]s[x,t][k]

);
DDsamp[x_,t_][k_]:=(\[Tau]ssamp[x,t][k]	0
0	1/\[Tau]ssamp[x,t][k]

);

Q[x_,t_][z_]:=(qn[x,t][z/Sqrt[t]-x/(4 t)]	0
0	1/qn[x,t][z/Sqrt[t]-x/(4 t)]

);*)



(* ::Input::Initialization:: *)
CME[x_]:=Chop[x,$MachineEpsilon];
ScatteringMatrixFiniteNLS[q_,n_,el_]:=Module[{qf,qfb,Dm,Dmb,IIm,IImb,P,Pb,id,Q,R,Qb,Rb,DM,DMb,q\[Sigma]1,q\[Sigma]1b,J\[Sigma]3,J\[Sigma]31,J\[Sigma]3b,J\[Sigma]31b,rhs,A,Ab},
       (*qf=Fun[q,Line[{-el,0}],n];*)
qfb=Fun[q,Line[{0,el}],n];
(*Print[{qf//Values//First//Abs,qf//DCTPlot}];*)
Print[{"q at right end point is ",qfb//Values//Last//Abs,"DCTPlot is ",qfb//DCTPlot}];
(*Dm=DerivativeMatrix[qf];*)
Dmb=DerivativeMatrix[qfb];
(*IIm=ReduceDimensionIntegrateMatrix[qf];*)
IImb=(ReduceDimensionIntegrateMatrix[(qfb//ReverseOrientation)]//Transpose//Reverse//Transpose//Reverse);
id=IdentityMatrix[n];
(*Q = DiagonalMatrix[qf//Values];
R= -\[Lambda] DiagonalMatrix[qf//Conjugate//Values];*)
Qb = DiagonalMatrix[qfb//Values];
Rb = (-\[Lambda]) DiagonalMatrix[qfb//Conjugate//Values];
(*A=BlockMatrix[{{id,-IIm.Q},{-IIm.R,id}}];*)
Ab=BlockMatrix[{{id,-IImb.Qb},{-IImb.Rb,id}}];
(*J\[Sigma]3=BlockMatrix[{{0*id,0},{0,-2I IIm}}];
J\[Sigma]31=BlockMatrix[{{2I IIm,0},{0,0*id}}];*)
J\[Sigma]3b=BlockMatrix[{{0*id,0},{0,-2I IImb}}];
J\[Sigma]31b=BlockMatrix[{{2I IImb,0},{0,0*id}}];
ScatteringMatrixFiniteNLS[qf,qfb,A,Ab,J\[Sigma]3,J\[Sigma]31,J\[Sigma]3b,J\[Sigma]31b,IIm,IImb]];
ScatteringMatrixFiniteNLS[qf_,qfb_,A_,Ab_,J\[Sigma]3_,J\[Sigma]31_,J\[Sigma]3b_,J\[Sigma]31b_,IIm_,IImb_][w_]:=Module[{ans0,ans1,rhs,lhs,n,s1,s2,qb,q,r,rb},
(*q = qf//Values;*)
qb = qfb//Values;
(*r = -\[Lambda] q//Conjugate;*)
rb=(-1)* (-\[Lambda] qb)//Conjugate;
n = qb//Length;

(*lhs=A+ w*J\[Sigma]3;
rhs = Join[ConstantArray[0.,n],IIm.r];
ans0 = LinearSolve[lhs//CME,rhs//CME];
(*Print["Linear solve 1 cond=",Max[SingularValueList[lhs,Tolerance\[Rule]0]]/Min[SingularValueList[lhs,Tolerance\[Rule]0]]];*)
lhs=A+w*J\[Sigma]31;
rhs=Join[IIm.q,ConstantArray[0.,n]];
ans1 = LinearSolve[lhs//CME,rhs//CME];
(*Print["Linear solve 2 cond=",Max[SingularValueList[lhs,Tolerance\[Rule]0]]/Min[SingularValueList[lhs,Tolerance\[Rule]0]]];
*)
s1={{ans0[[n]]+1,-ans1[[n]]},{ans0[[2n]],-ans1[[2n]]-1}};*)

lhs=Ab+ w*J\[Sigma]3b;
rhs = Join[ConstantArray[0.,n],IImb.rb];
ans0 = LinearSolve[lhs//CME,rhs//CME];
(*Print["Linear solve 3 cond=",Max[SingularValueList[lhs,Tolerance\[Rule]0]]/Min[SingularValueList[lhs,Tolerance\[Rule]0]]];
*)

lhs=Ab+ w*J\[Sigma]31b;
rhs = Join[IImb.qb,ConstantArray[0.,n]];
ans1 = LinearSolve[lhs//CME,rhs//CME];
(*Print["Linear solve 4 cond=",Max[SingularValueList[lhs,Tolerance\[Rule]0]]/Min[SingularValueList[lhs,Tolerance\[Rule]0]]];
*)
(*s2={{ans0[[1]]+1,ans1[[1]]},{ans0[[n+1]],ans1[[n+1]]+1}};*)
(*s1=Inverse[s2].s1*)
(*s1={{ans1[[n+1]]+1,0},{ans1[[1]],0}}??? test*)
s1={{ans1[[n+1]]+1,0},{ans1[[1]],0}}
];


(* ::Input::Initialization:: *)
HillNLS[F_,n_]:=Module[{c2,c1,c0,f11,f12,zz,f02,f01,t,A,mu,L,P,fun},
mu = .25;
L = Pi;
P =1;
f11[x_]:= 2I Cos[x/2]^2;
f12[x_]:=-2I Cos[x/2]^2;
zz[x_]:=ConstantArray[0.,Length[x]];
t[x_] := Tan[x/2];   (* *)
f02[x_]:= -I F[t[x]];
f01[x_]:=-\[Lambda] I Conjugate[F[t[x]]];
fun= {{{zz,f11},{f02,zz}},{{f01,zz},{zz,f12}}};
A= Hill[mu,L,n,P,fun];
Eigenvalues[Chop[A,$MachineEpsilon]]
];
LocatePolesNLS[F_,n_]:=Module[{eval,s,i,sys,vecs},
Off[General::unfl];
eval=HillNLS[F,n];
s = {};
For[i=1,i<=Length[eval],i++,
If[Im[eval[[i]]]>10^(-4)&& Abs[eval[[i]]]<30,  (*why this condition, looking for non real eigen value*)
s=Join[s,{eval[[i]]}];
];
];
On[General::unfl];
Chop[s,$MachineEpsilon]
];


(* ::Input::Initialization:: *)
J[0][x_,t_]:={{G1[x,t][#]&,G2[x,t][#]&,G3[x,t][#]&,G4[x,t][#]&},{Line[{el*I,0}],Line[{0,-el}],Line[{-el*I,0}],Line[{0,2*el}]},{bigN,2*bigN,bigN,4*bigN}};
Jsamp[0][x_,t_]:={{G1samp[x,t][#]&,G2samp[x,t][#]&,G3samp[x,t][#]&,G4samp[x,t][#]&},{Line[{el*I,0}],Line[{0,-el}],Line[{-el*I,0}],Line[{0,2*el}]},{bigN,2*bigN,bigN,4*bigN}};
Jadapt[0][x_,t_]:=Adapt[Jsamp[0][x,t],globalTol][J[0][x,t]];
(*Jadapt[0][x_,t_]:=J[0][x,t];*)


(* ::Input::Initialization:: *)
(*SmallTimeContour={Line[{-el + I \[Nu],Sqrt[2]\[Nu] Exp[I 3 Pi/4]}],Line[{Sqrt[2]\[Nu] Exp[I 3 Pi/4],0}],
Line[{-el,0}],
Line[{-el - I \[Nu],Sqrt[2]\[Nu] Exp[I 5 Pi/4]}],
Line[{Sqrt[2]\[Nu] Exp[I 5 Pi/4],0}],
Line[{0,Sqrt[2]\[Nu] Exp[I Pi/4]}],
Line[{Sqrt[2]\[Nu] Exp[I Pi/4],I \[Nu] + el}],
Line[{0,Sqrt[2]\[Nu] Exp[-I Pi/4]}],
Line[{Sqrt[2]\[Nu] Exp[-I Pi/4],-I \[Nu] + el}]};
Modk0[x_,t_]:=If[t < 10*$MachineEpsilon,-Sign[x]*100,-Sign[x]*Min[Abs[x/(4t)],100]];*)


(* ::Input::Initialization:: *)
(*J[1][x_,t_]:={{Un[x,t][#]&,Un[x,t][#]&,
DDn[#]&,Ln[x,t][#]&,Ln[x,t][#]&,Pn[x,t][#]&,Pn[x,t][#]&,Mn[x,t][#]&,Mn[x,t][#]&}, SmallTimeContour + Modk0[x,t], {bigN,smallN,bigN,bigN,smallN,smallN,bigN,smallN,bigN}};
Jsamp[1][x_,t_]:={{Unsamp[x,t][#]&,Unsamp[x,t][#]&,
DDnsamp[#]&,Lnsamp[x,t][#]&,Lnsamp[x,t][#]&,Pnsamp[x,t][#]&,Pnsamp[x,t][#]&,Mnsamp[x,t][#]&,Mnsamp[x,t][#]&}, SmallTimeContour + Modk0[x,t],{bigN,smallN,bigN,bigN,smallN,smallN,bigN,smallN,bigN}};
Jadapt[1][x_,t_]:=Adapt[Jsamp[1][x,t],globalTol][J[1][x,t]]*)


(* ::Input::Initialization:: *)
s0[x_,t_]:=N[If[Abs[t]<0.0001,-el,-Min[x/4/t,el]]];
J[1][x_,t_]:={{G1[x,t][#]&,L[x,t][#]&,L[x,t][#]&,DD[#]&,U[x,t][#]&,U[x,t][#]&,G3[x,t][#]&,M[x,t][#]&,M[x,t][#]&,P[x,t][#]&,P[x,t][#]&},{Line[{el*Exp[I*Pi/4]+s0[x,t],0+s0[x,t]}],
Line[{0+s0[x,t],Exp[-I*3*Pi/4]*\[Nu]+s0[x,t]}],Line[{Exp[-3I*Pi/4]*\[Nu]+s0[x,t],Exp[-I*3*Pi/4]*\[Nu]+s0[x,t]-el}],
Line[{0+s0[x,t],-el+s0[x,t]}],
Line[{0+s0[x,t],Exp[I*3*Pi/4]*\[Nu]+s0[x,t]}],Line[{Exp[I*3*Pi/4]*\[Nu]+s0[x,t],Exp[I*3*Pi/4]*\[Nu]+s0[x,t]-el}],
Line[{el*Exp[-I*Pi/4]+s0[x,t],0+s0[x,t]}],
Line[{0+s0[x,t],Exp[-I*Pi/4]*\[Nu]+s0[x,t]}],Line[{Exp[-I*Pi/4]*\[Nu]+s0[x,t],Exp[-I*Pi/4]*\[Nu]+s0[x,t]+el}],
Line[{0+s0[x,t],Exp[I*Pi/4]*\[Nu]+s0[x,t]}],Line[{Exp[I*Pi/4]*\[Nu]+s0[x,t],Exp[I*Pi/4]*\[Nu]+s0[x,t]+el}]},{bigN,bigN,bigN,bigN*3,bigN,bigN,bigN,bigN,bigN,bigN,bigN}};
Jsamp[1][x_,t_]:={{G1samp[x,t][#]&,Lsamp[x,t][#]&,Lsamp[x,t][#]&,DDsamp[#]&,Usamp[x,t][#]&,Usamp[x,t][#]&,G3samp[x,t][#]&,Msamp[x,t][#]&,Msamp[x,t][#]&,Psamp[x,t][#]&,Psamp[x,t][#]&},
{Line[{el*Exp[I*Pi/4]+s0[x,t],0+s0[x,t]}],
Line[{0+s0[x,t],Exp[-I*3*Pi/4]*\[Nu]+s0[x,t]}],Line[{Exp[-3I*Pi/4]*\[Nu]+s0[x,t],Exp[-I*3*Pi/4]*\[Nu]+s0[x,t]-el}],
Line[{0+s0[x,t],-el+s0[x,t]}],
Line[{0+s0[x,t],Exp[I*3*Pi/4]*\[Nu]+s0[x,t]}],Line[{Exp[I*3*Pi/4]*\[Nu]+s0[x,t],Exp[I*3*Pi/4]*\[Nu]+s0[x,t]-el}],
Line[{el*Exp[-I*Pi/4]+s0[x,t],0+s0[x,t]}],
Line[{0+s0[x,t],Exp[-I*Pi/4]*\[Nu]+s0[x,t]}],Line[{Exp[-I*Pi/4]*\[Nu]+s0[x,t],Exp[-I*Pi/4]*\[Nu]+s0[x,t]+el}],
Line[{0+s0[x,t],Exp[I*Pi/4]*\[Nu]+s0[x,t]}],Line[{Exp[I*Pi/4]*\[Nu]+s0[x,t],Exp[I*Pi/4]*\[Nu]+s0[x,t]+el}]},{bigN,bigN,bigN,bigN*3,bigN,bigN,bigN,bigN,bigN,bigN,bigN}};
Jadapt[1][x_,t_]:=Adapt[Jsamp[1][x,t],globalTol][J[1][x,t]];


(* ::Input::Initialization:: *)
DDI[x_,t_][k_]:=If[Im[k] >=0,DD[x,t][k],IdentityMatrix[2]];
startift[]:=Module[{},
Clear[ift];
ift[k0_]:=ift[k0]=Fun[Log[\[Tau][#]]&,{LeftEndpoint[dom],k0}//Line,100];
];
startift[];
\[Delta]t[x_,t_][s_,k_]:=(Cauchy[s,ift[-x/(4 t)],k]//Exp);
\[Delta]t[x_,t_][k_]:=(Cauchy[ift[-x/(4 t)],k]//Exp);
\[CapitalPhi]t[x_,t_][z__]:=({
 {\[Delta]t[x,t][z], 0},
 {0, 1/\[Delta]t[x,t][z]}
});
\[CapitalPhi]tin[t__][z__]:=({
 {1/\[Delta]t[t][z], 0},
 {0, \[Delta]t[t][z]}
});
\[CapitalPhi]ts[x_,t_][z_]:=\[CapitalPhi]t[x,t][z/Sqrt[t]-x/(4 t)];
\[CapitalPhi]tins[x_,t_][z_]:=\[CapitalPhi]tin[x,t][z/Sqrt[t]-x/(4 t)];
MaxRads[x_,t_]:={Min[Sqrt[2]\[Nu] *Sqrt[t],100],Min[Sqrt[2]\[Nu] *Sqrt[t]/2,1]};
J[2][x_,t_]:=Module[{Jumps,Domains,NumPts},
Jumps={
\[CapitalPhi]ts[x,t][#].L[x,t][#].\[CapitalPhi]tins[x,t][#]&,
\[CapitalPhi]ts[x,t][#].L[x,t][#].\[CapitalPhi]tins[x,t][#]&,
\[CapitalPhi]ts[x,t][#].U[x,t][#].\[CapitalPhi]tins[x,t][#]&,
\[CapitalPhi]ts[x,t][#].U[x,t][#].\[CapitalPhi]tins[x,t][#]&,
\[CapitalPhi]ts[x,t][#].M[x,t][#].\[CapitalPhi]tins[x,t][#]&,
\[CapitalPhi]ts[x,t][#].M[x,t][#].\[CapitalPhi]tins[x,t][#]&,
\[CapitalPhi]ts[x,t][#].P[x,t][#].\[CapitalPhi]tins[x,t][#]&,
\[CapitalPhi]ts[x,t][#].P[x,t][#].\[CapitalPhi]tins[x,t][#]&,
DDI[x,t][#].\[CapitalPhi]tins[x,t][#]&,
DD[x,t][#].U[x,t][#].\[CapitalPhi]tins[x,t][#]&,
Lin[x,t][#].M[x,t][#].\[CapitalPhi]tins[x,t][#]&,
Lin[x,t][#].\[CapitalPhi]tins[x,t][#]&
};
Domains={
Line[{-el Sqrt[t] - I \[Nu] Sqrt[t],MaxRads[x,t][[1]]Exp[-3I \[Pi]/4.]}],
Line[MaxRads[x,t]Exp[-3I \[Pi]/4.]],
Line[{-el Sqrt[t] + I \[Nu] Sqrt[t],MaxRads[x,t][[1]]Exp[3I \[Pi]/4.]}],
Line[MaxRads[x,t]Exp[3I \[Pi]/4.]],
Line[Reverse[MaxRads[x,t]]Exp[-I \[Pi]/4.]],
Line[{MaxRads[x,t][[1]]Exp[-I \[Pi]/4.],el Sqrt[t] - I \[Nu] Sqrt[t]}],
Line[Reverse[MaxRads[x,t]]Exp[I \[Pi]/4.]],
Line[{MaxRads[x,t][[1]]Exp[I \[Pi]/4.],el Sqrt[t] + I \[Nu] Sqrt[t]}],
Line[{Exp[-3I \[Pi]/4],Exp[3I \[Pi]/4]}*MaxRads[x,t][[2]]],
Line[{Exp[3I \[Pi]/4],Exp[I \[Pi]/4]}*MaxRads[x,t][[2]]],
Line[{Exp[I \[Pi]/4],Exp[- I \[Pi]/4]}*MaxRads[x,t][[2]]],
Line[{Exp[-I \[Pi]/4],Exp[-3 I \[Pi]/4]}*MaxRads[x,t][[2]]]
};
NumPts=Table[smallN,{i,1,12}];
NumPts[[1]]=bigN;
NumPts[[3]]=bigN;
NumPts[[6]]=bigN;
NumPts[[8]]=bigN;
{Jumps,Domains,NumPts}
];
Jsamp[2][x_,t_]:=Module[{Jumps,Domains,NumPts},
Jumps={
Lsamp[x,t][#]&,
Lsamp[x,t][#]&,
Usamp[x,t][#]&,
Usamp[x,t][#]&,
Msamp[x,t][#]&,
Msamp[x,t][#]&,
Psamp[x,t][#]&,
Psamp[x,t][#]&,
DDsamp[x,t][#]&,
DDsamp[x,t][#].Usamp[x,t][#]&,
Linsamp[x,t][#].Msamp[x,t][#]&,
Linsamp[x,t][#]&};
Domains={
Line[{-el Sqrt[t] - I \[Nu] Sqrt[t],MaxRads[x,t][[1]]Exp[-3I \[Pi]/4.]}],
Line[MaxRads[x,t]Exp[-3I \[Pi]/4.]],
Line[{-el Sqrt[t] + I \[Nu] Sqrt[t],MaxRads[x,t][[1]]Exp[3I \[Pi]/4.]}],
Line[MaxRads[x,t]Exp[3I \[Pi]/4.]],
Line[Reverse[MaxRads[x,t]]Exp[-I \[Pi]/4.]],
Line[{MaxRads[x,t][[1]]Exp[-I \[Pi]/4.],el Sqrt[t] - I \[Nu] Sqrt[t]}],
Line[Reverse[MaxRads[x,t]]Exp[I \[Pi]/4.]],
Line[{MaxRads[x,t][[1]]Exp[I \[Pi]/4.],el Sqrt[t] + I \[Nu] Sqrt[t]}],
Line[{Exp[-3I \[Pi]/4],Exp[3I \[Pi]/4]}*MaxRads[x,t][[2]]],
Line[{Exp[3I \[Pi]/4],Exp[I \[Pi]/4]}*MaxRads[x,t][[2]]],
Line[{Exp[I \[Pi]/4],Exp[- I \[Pi]/4]}*MaxRads[x,t][[2]]],
Line[{Exp[-I \[Pi]/4],Exp[-3 I \[Pi]/4]}*MaxRads[x,t][[2]]]
};
NumPts=Table[smallN,{i,1,12}];
NumPts[[1]]=bigN;
NumPts[[3]]=bigN;
NumPts[[6]]=bigN;
NumPts[[8]]=bigN;
{Jumps,Domains,NumPts}
];
Jadapt[2][x_,t_]:=Adapt[Jsamp[2][x,t],globalTol][J[2][x,t]]


(* ::Input::Initialization:: *)
DDIn[k_]:=If[Im[k] >=0,DDn[k],IdentityMatrix[2]];
MaxRadsn[x_,t_]:={Sqrt[2]\[Nu] ,Sqrt[2]\[Nu] /(2(1+Sqrt[t]))};
J[3][x_,t_]:=Module[{Jumps,Domains,NumPts},
Jumps={
\[CapitalPhi]t[x,t][#].Ln[x,t][#].\[CapitalPhi]tin[x,t][#]&,
\[CapitalPhi]t[x,t][#].Ln[x,t][#].\[CapitalPhi]tin[x,t][#]&,
\[CapitalPhi]t[x,t][#].Un[x,t][#].\[CapitalPhi]tin[x,t][#]&,
\[CapitalPhi]t[x,t][#].Un[x,t][#].\[CapitalPhi]tin[x,t][#]&,
\[CapitalPhi]t[x,t][#].Mn[x,t][#].\[CapitalPhi]tin[x,t][#]&,
\[CapitalPhi]t[x,t][#].Mn[x,t][#].\[CapitalPhi]tin[x,t][#]&,
\[CapitalPhi]t[x,t][#].Pn[x,t][#].\[CapitalPhi]tin[x,t][#]&,
\[CapitalPhi]t[x,t][#].Pn[x,t][#].\[CapitalPhi]tin[x,t][#]&,
DDIn[#].\[CapitalPhi]tin[x,t][#]&,
DDn[#].Un[x,t][#].\[CapitalPhi]tin[x,t][#]&,
Linn[x,t][#].Mn[x,t][#].\[CapitalPhi]tin[x,t][#]&,
Linn[x,t][#].\[CapitalPhi]tin[x,t][#]&
};
Domains={
Line[{-el  - I \[Nu] ,MaxRadsn[x,t][[1]]Exp[-3I \[Pi]/4.]}],
Line[MaxRadsn[x,t]Exp[-3I \[Pi]/4.]],
Line[{-el + I \[Nu] ,MaxRadsn[x,t][[1]]Exp[3I \[Pi]/4.]}],
Line[MaxRadsn[x,t]Exp[3I \[Pi]/4.]],
Line[Reverse[MaxRadsn[x,t]]Exp[-I \[Pi]/4.]],
Line[{MaxRadsn[x,t][[1]]Exp[-I \[Pi]/4.],el - I \[Nu] }],
Line[Reverse[MaxRadsn[x,t]]Exp[I \[Pi]/4.]],
Line[{MaxRadsn[x,t][[1]]Exp[I \[Pi]/4.],el  + I \[Nu] }],
Line[{Exp[-3I \[Pi]/4],Exp[3I \[Pi]/4]}*MaxRadsn[x,t][[2]]],
Line[{Exp[3I \[Pi]/4],Exp[I \[Pi]/4]}*MaxRadsn[x,t][[2]]],
Line[{Exp[I \[Pi]/4],Exp[- I \[Pi]/4]}*MaxRadsn[x,t][[2]]],
Line[{Exp[-I \[Pi]/4],Exp[-3 I \[Pi]/4]}*MaxRadsn[x,t][[2]]]
};
Domains=Domains-x/(4t);
NumPts=Table[smallN,{i,1,12}];
NumPts[[1]]=bigN;
NumPts[[3]]=bigN;
NumPts[[6]]=bigN;
NumPts[[8]]=bigN;
{Jumps,Domains,NumPts}
];
Jsamp[3][x_,t_]:=Module[{Jumps,Domains,NumPts},
Jumps={
Lnsamp[x,t][#]&,
Lnsamp[x,t][#]&,
Unsamp[x,t][#]&,
Unsamp[x,t][#]&,
Mnsamp[x,t][#]&,
Mnsamp[x,t][#]&,
Pnsamp[x,t][#]&,
Pnsamp[x,t][#]&,
Lnsamp[x,t][#]&,
Lnsamp[x,t][#].Unsamp[x,t][#]&,
Lnsamp[x,t][#].Mnsamp[x,t][#]&,
Lnsamp[x,t][#]&
};
Domains={
Line[{-el  - I \[Nu] ,MaxRadsn[x,t][[1]]Exp[-3I \[Pi]/4.]}],
Line[MaxRadsn[x,t]Exp[-3I \[Pi]/4.]],
Line[{-el + I \[Nu] ,MaxRadsn[x,t][[1]]Exp[3I \[Pi]/4.]}],
Line[MaxRadsn[x,t]Exp[3I \[Pi]/4.]],
Line[Reverse[MaxRadsn[x,t]]Exp[-I \[Pi]/4.]],
Line[{MaxRadsn[x,t][[1]]Exp[-I \[Pi]/4.],el - I \[Nu] }],
Line[Reverse[MaxRadsn[x,t]]Exp[I \[Pi]/4.]],
Line[{MaxRadsn[x,t][[1]]Exp[I \[Pi]/4.],el  + I \[Nu] }],
Line[{Exp[-3I \[Pi]/4],Exp[3I \[Pi]/4]}*MaxRadsn[x,t][[2]]],
Line[{Exp[3I \[Pi]/4],Exp[I \[Pi]/4]}*MaxRadsn[x,t][[2]]],
Line[{Exp[I \[Pi]/4],Exp[- I \[Pi]/4]}*MaxRadsn[x,t][[2]]],
Line[{Exp[-I \[Pi]/4],Exp[-3 I \[Pi]/4]}*MaxRadsn[x,t][[2]]]
};
Domains=Domains-x/(4t);
NumPts=Table[smallN,{i,1,12}];
NumPts[[1]]=bigN;
NumPts[[3]]=bigN;
NumPts[[6]]=bigN;
NumPts[[8]]=bigN;
{Jumps,Domains,NumPts}
];
Jadapt[3][x_,t_]:=Adapt[Jsamp[3][x,t],globalTol][J[3][x,t]]


(* ::Input::Initialization:: *)
InvScale[x_,t_][k_]:=Sqrt[t](k+x/(4t));
Scaling[x_,t_][k_]:=k/Sqrt[t] -x/(4t);
Tn[+1][x_,t_,a_,c_][z_]:=({
 {1, 0},
 {-c Exp[\[Theta][x,t][a]]/(z-a), 1}
});
Tn[-1][x_,t_,a_,c_][z_]:=({
 {1, \[Lambda] cc[-c Exp[\[Theta][x,t][a]]/(cc[z]-a)]},
 { 0, 1}
});
Sn[+1][x_,t_,a_,c_][z_]:=({
 {1, -(z-a)/c*Exp[-\[Theta][x,t][a]]},
 {0, 1}
});
Sn[-1][x_,t_,a_,c_][z_]:=({
 {1, 0},
 {\[Lambda] cc[-(cc[z]-a)/c*Exp[-\[Theta][x,t][a]]], 1}
});
ContourArrayn[+1,r_,a_]:={Arc[a,r,{0,Pi}],Arc[a,r,{Pi,2Pi}]};
ContourArrayn[-1,r_,a_]:={Arc[a//cc,r,{0,-Pi}],Arc[a//cc,r,{-Pi,-2Pi}]};

T[+1][x_,t_,a_,c_][z_]:=Tn[+1][x,t,a,c][Scaling[x,t][z]];
T[-1][x_,t_,a_,c_][z_]:=Tn[-1][x,t,a,c][Scaling[x,t][z]];
S[+1][x_,t_,a_,c_][z_]:=Sn[+1][x,t,a,c][Scaling[x,t][z]];
S[-1][x_,t_,a_,c_][z_]:=Sn[-1][x,t,a,c][Scaling[x,t][z]];


(* ::Input::Initialization:: *)
ContourArray[+1,r_,a_,x_,t_]:={Arc[InvScale[x,t][a],r*Sqrt[t],{0,Pi}],Arc[InvScale[x,t][a],r*Sqrt[t],{Pi,2Pi}]};
ContourArray[-1,r_,a_,x_,t_]:={Arc[InvScale[x,t][a//cc],r*Sqrt[t],{0,-Pi}],Arc[InvScale[x,t][a//cc],r*Sqrt[t],{-Pi,-2Pi}]};

PoleListn[x_,t_]:=Module[{out,i,Domain,Jumps,Points},
Domain={};
Jumps={};
Points={};
For[i=1,i<=Length[a],i++,
If[1/globalTol>Abs[c[[i]]]Exp[Re[\[Theta][x,t][a[[i]]]]]&&Abs[c[[i]]]Exp[Re[\[Theta][x,t][a[[i]]]]]> globalTol,
If[Abs[c[[i]]]Exp[Re[\[Theta][x,t][a[[i]]]]]>expconst,
Jumps=Join[Jumps,{Sn[+1][x,t,a[[i]],c[[i]]],Sn[+1][x,t,a[[i]],c[[i]]]}];
Jumps=Join[Jumps,{Sn[-1][x,t,a[[i]],c[[i]]],Sn[-1][x,t,a[[i]],c[[i]]]}];
flag="pos";,
Jumps = Join[Jumps,{Tn[+1][x,t,a[[i]],c[[i]]],Tn[+1][x,t,a[[i]],c[[i]]]}];
Jumps = Join[Jumps,{Tn[-1][x,t,a[[i]],c[[i]]],Tn[-1][x,t,a[[i]],c[[i]]]}];
flag="neg";
];
Domain= Join[Domain,Join[ContourArrayn[+1,rad,a[[i]]],ContourArrayn[-1,rad,a[[i]]]]];
Points=Join[Points,{smallN,smallN,smallN,smallN}];
];
];
{Jumps,Domain,Points}
];
PoleList[x_,t_]:=Module[{out,i,Domain,Jumps,Points},
Domain={};
Jumps={};
Points={};
For[i=1,i<=Length[a],i++,
If[1/tol >Abs[c[[i]]]Exp[Re[\[Theta][x,t][a[[i]]]]]> tol,
If[Abs[c[[i]]]Exp[Re[\[Theta][x,t][a[[i]]]]]>expconst,
Jumps=Join[Jumps,{S[+1][x,t,a[[i]],c[[i]]],Sn[+1][x,t,a[[i]],c[[i]]]}];
Jumps=Join[Jumps,{S[-1][x,t,a[[i]],c[[i]]],Sn[-1][x,t,a[[i]],c[[i]]]}];
flag="pos";,
Jumps = Join[Jumps,{T[+1][x,t,a[[i]],c[[i]]],Tn[+1][x,t,a[[i]],c[[i]]]}];
Jumps = Join[Jumps,{T[-1][x,t,a[[i]],c[[i]]],Tn[-1][x,t,a[[i]],c[[i]]]}];
flag="neg";
];
Domain= Join[Domain,Join[ContourArray[+1,rad,a[[i]]],ContourArray[-1,rad,a[[i]]]]];
Points=Join[Points,{smallN,smallN,smallN,smallN}];
];
];
{Jumps,Domain,Points}
];


(* ::Input::Initialization:: *)
DomainIntegrate[0.]:=0;
tcrit=8;
NLS[i_][x_,t_]:=Module[{rhp2,scale,\[CapitalPhi]1,\[CapitalPhi]2,\[CapitalPhi],out,t1,t2,t3,t4,poles},
If[i==2,scale=True,scale=False];
RHSolved//Clear;
RHSolved[X_]:=RHSolved[X]=RHSolve[X];
RHSolved[{}]:=0.;
RHSolution[X_][z_]:=Cauchy[X//RHSolved,z]+IdentityMatrix[2];

If[scale,
t1=Timing[rhp1=ConjugateList[Jadapt[i][x,t],Q[x,t]]rh//MakeListFun;];
t2=Timing[RHSolved[rhp1];];
\[CapitalPhi]1[k_]:=RHSolution[rhp1][InvScale[x,t][k]]//Inverse;,
t1=Timing[rhp1=ConjugateList[Jadapt[i][x,t],Qn[x,t]]//MakeListFun;];
t2=Timing[RHSolved[rhp1];];
\[CapitalPhi]1[k_]:=RHSolution[rhp1][k]//Inverse;
];
domainOutput = DomainPlot[rhp1];

rhp2= ConjugateList[PoleListn[x,t],Qn[x,t]];
If[i>1,
rhp2= ConjugateList[rhp2,\[CapitalPhi]tin[x,t]];
];
t3=Timing[rhp2= ConjugateList[rhp2,\[CapitalPhi]1]//MakeListFun;];
t4=Timing[RHSolved[rhp2];];
\[CapitalPhi]2 = RHSolution[rhp2];
\[CapitalPhi][k_]:=RHSolution[rhp2][k].RHSolution[rhp1][k];
out=-(DomainIntegrate[RHSolved[rhp1]] If[scale,1/Sqrt[t],1]+DomainIntegrate[RHSolved[rhp2]])[[1,2]]/Pi;
timestring= "Region: " <>ToString[i]<>" ("<>ToString[x]<>","<>ToString[t]<>") "<>"1) Construct: " <> ToString[t1//First]<>"  "<>"1) Solve: " <> ToString[t2//First]<>"  "<>"2) Construct: " <> ToString[t3//First]<>"  "<>"2) Solve: " <> ToString[t4//First];
If[timeflag,Print[timestring];];
{out,\[CapitalPhi],rhp1,rhp2,timestring}
];
(*all undeformed for now*)
NLSAuto[x_,t_]:=\[Piecewise]{
 {NLS[1][x,t][[1]], Abs[x]<=5&&t<.1},
 {NLS[1][x,t][[1]], t>tcrit},
 {NLS[1][x,t][[1]], True}
}



(* ::Input::Initialization:: *)
(*NLS[x_,t_]:=-DomainIntegrate[RHSolveTop[JNLS[x,t]]]\[LeftDoubleBracket]2\[RightDoubleBracket]/( \[Pi]\[NonBreakingSpace])*If[t>tcrit,1/Sqrt[t],1];
NLSSelect[i_][x_,t_]:=-DomainIntegrate[RHSolveTop[G[i][x,t]]]\[LeftDoubleBracket]2\[RightDoubleBracket]/( \[Pi]\[NonBreakingSpace])*If[i\[Equal]2,1/Sqrt[t],1];*)


(* ::Input::Initialization:: *)
End[];
