(* ::Package:: *)

(************************************************************************)
(* This file was generated automatically by the Mathematica front end.  *)
(* It contains Initialization cells from a Notebook file, which         *)
(* typically will have the same name as this file except ending in      *)
(* ".nb" instead of ".m".                                               *)
(*                                                                      *)
(* This file is intended to be loaded into the Mathematica kernel using *)
(* the package loading commands Get or Needs.  Doing so is equivalent   *)
(* to using the Evaluate Initialization Cells menu command in the front *)
(* end.                                                                 *)
(*                                                                      *)
(* DO NOT EDIT THIS FILE.  This entire file is regenerated              *)
(* automatically each time the parent Notebook file is saved in the     *)
(* Mathematica front end.  Any changes you make to this file will be    *)
(* overwritten.                                                         *)
(************************************************************************)



(* ::Input::Initialization:: *)
Needs["RiemannHilbert`"];
HillNLS::usage="HillNLS[q,n] gives the eigenvalues of the modified Zakharov-Shabat scattering (including continuous spectrum) problem with n Fourier modes using Hill's method.";
LocatePolesNLS::usage="LocatePoles[q,n] gives the true eigenvalues of the modified Zakharov-Shabat scattering problem.";
NLS::usage="NLS[i][x,t] = {out,\[CapitalPhi],rhp1,rhp2,timestring} where out is the solution of NLS, \[CapitalPhi] is the solution of the Riemann-Hilbert problem, rhp1 and rhp2 are the Riemann-Hilbert problems and timestring is the string of computation times.  This is done using the deformation in Region i.";
NLSAuto::usage="NLSAuto[x,t] returns the solution of the NLS equation with deformation selected automagically.  Many things must be initialized.  Sample code:

	q[x_]:=.1 Exp[-x^2+I x];\[IndentingNewLine]Defocusing[];
	H=ScatteringMatrixFiniteNLS[q,50,6];\[IndentingNewLine]aa//Clear;bb//Clear;\[IndentingNewLine]aa[k_]:=aa[k]=H[k][[1,1]];\[IndentingNewLine]bb[k_]:=bb[k]=H[k][[2,1]];
	SetParams[.6,.1,10.^(-9),15,30];\[IndentingNewLine]h[k_]:=3/(1+Abs[k/2+1/3.2]^8);\[IndentingNewLine]Setrsamp[h];\[IndentingNewLine]Settimeflag[False];\[IndentingNewLine]\[Nu]=Getnu[];\[IndentingNewLine]\[Rho][k_]:=bb[k]/aa[k];
	up=I(\[Nu]+.0001);m=40;el=8;\[IndentingNewLine]f={Fun[\[Rho],Line[{-el,0}-up],m],Fun[\[Rho],Line[{0,el}-up],m],Fun[\[Rho],Line[{el,0}+up],m],Fun[\[Rho],Line[{0,-el}+up],m]};

	up=I(\[Nu]+.0001);m=40;el=8;\[IndentingNewLine]f={Fun[\[Rho],Line[{-el,0}-up],m],Fun[\[Rho],Line[{0,el}-up],m],Fun[\[Rho],Line[{el,0}+up],m],Fun[\[Rho],Line[{0,-el}+up],m]};
SetScatteringData[aa,bb,m\[Rho],LocatePoles[q,40]]"
Focusing::usage="Focusing[], switch to focusing NLS";
Defocusing::usage="Defocusing[], switch to focusing NLS";
SetScatteringData::usage="SetScatteringData[a,b,\[Rho],poles] or SetScatteringData[a,b,\[Rho],poles,normingConstants] sets the scattering data for the NLS equation";
SetParams::usage="SetParams[\[Nu],rad,globalTol,smallN,bigN] sets the parameters for the rest of the code:
	\[Nu]: half of width of strip of analyticity
	rad: radius of soliton contours
	globalTol: contour truncation tolerance
	smallN: small number of collocation points
	bigN: big number of collocation points";
GetScatteringData::usage="GetScatteringData[] = {\[Rho],poles,normingConstants}";
ScatteringMatrixFiniteNLS::usage="ScatteringMatrixFiniteNLS[q,n,L] returns a function f[w] that produces an approximation of the scattering matrix at w. The parameter n indicates the number of collocation points and L sets the problem on [-L,L]
Sample code:
	q[x_]:=.1 Exp[-x^2+I x];\[IndentingNewLine]Defocusing[];
	H=ScatteringMatrixFiniteNLS[q,50,6];\[IndentingNewLine]aa//Clear;bb//Clear;\[IndentingNewLine]aa[k_]:=aa[k]=H[k][[1,1]];\[IndentingNewLine]bb[k_]:=bb[k]=H[k][[2,1]];
";
ScatteringMatrixBFiniteNLS::usage="ScatteringMatrixBFiniteNLS[g0,g1,n,L] returns a function f[w] that produces an approximation of the scattering matrix at w. The parameter n indicates the number of collocation points and L sets the problem on [-L,L]
";
Getnu::usage="Getnu[] returns \[Nu]";
Setrsamp::usage="Setrsamp[h] sets a function that should be chosen so that that |\[Rho]| < h";
timestring::usage="A string updated by NLS[i][x,t]
(x,t) 1) Construct: --time to construct rhp1-- 1) Solve: --time to solve rhp1-- 2) Construct: --time to construct rhp2-- 2) Solve: --time to solve rhp2--";
Settimeflag::usage="Settimeflag[bool] bool = True forces timestring to be printed each time NLS[i][x,t] is called";
startift;
domainOutput;
ift;
\[CapitalPhi]t;
dom;
Jadapt;J;Jsamp;
L;U;DD;G2;
rhp1;rhp2;
Begin["Private`"];


(* ::Input::Initialization:: *)
Focusing[]:=Module[{},\[Lambda]=1];
Defocusing[]:=Module[{},\[Lambda]=-1];
(*SetScatteringData[aa_,bb_,rr_,ma_,mc_]:=Module[{},
r[k_]:=rr[k];
a=ma;
\[Tau][k_]:=1+\[Lambda] r[k]cc[r[cc[k]]];
\[Tau][_?InfinityQ]:=1;
\[Tau][k_List]:=\[Tau]/@k;
dom=Truncate[globalTol][{Log[\[Tau][#]]&,Line[{-el,el}],100}][[1]];
Print[dom];
c=mc;
];*)
SetScatteringData[g_,G_,A1_,C1_,A2_,C2_]:=Module[{},
gam=g;
Gam=G;
a=A1;
c=C1;
];
(*SetScatteringData[aa_,bb_,rr_,ma_]:=Module[{},
(*r[k_]:=rr[k];*)
a=ma;
a1=aa;
b1=bb;
(*\[Tau][k_]:=1+\[Lambda] r[k]cc[r[cc[k]]];
\[Tau][_?InfinityQ]:=1;
\[Tau][k_List]:=\[Tau]/@k;need this for poles but tao is used for other names now*)
c={};
If[ma\[NotEqual] {},
(*dom=Truncate[globalTol][{Log[\[Tau][#]]&,Line[{-el,el}],100}][[1]];
Print[dom];*)
df1=f1';
da[k_]:=Cauchy[df1,k];
c={};
For[i=1,i\[LessEqual]Length[ma],i++,
c=Join[c,{Quiet[bb[ma[[i]]]]/da[ma[[i]]]}];(*compute norming constants*)
];
];
];*)
SetParams[nu_,rad1_,tol_,sN_,bN_,length_]:=Module[{},
\[Nu]=nu; (*parameter for width of strip of analyticity*)
rad=rad1;
globalTol=tol;
smallN=sN;
bigN=bN;
el=length;
];
GetScatteringData[]:=Module[{},{r,a,c}];
Getnu[]:=\[Nu];
Setrsamp[h_]:=Module[{},rsamp=h];
Settimeflag[h_]:=Module[{},timeflag=h];
SetN[x_]:=Module[{},bigN=x[[1]];smallN=x[[2]];];
expconst=1;(*having this large solves the bug, looks like invertion is the reason*)
bigN=20;
smallN=10;
el=30;


(* ::Input::Initialization:: *)
(*delta0[k_]:=a1[k]*Conjugate[a1[-Conjugate[k]]]+\[Lambda]*Conjugate[b1[-Conjugate[k]]]*b1[k];
gam[k_]:=b1[k]/Conjugate[a1[Conjugate[k]]];d[k_]:=a1[k]*Conjugate[A1[Conjugate[k]]]+\[Lambda]*Conjugate[B1[Conjugate[k]]]*b1[k];
Gam[k_]:=(-\[Lambda])*Conjugate[B1[Conjugate[k]]]/a1[k]/d[k];*)

(*(*homo neumann*)
delta1[k_]:=a1[k]*Conjugate[a1[-Conjugate[k]]]-\[Lambda]*Conjugate[b1[-Conjugate[k]]]*b1[k];
gam[k_]:=b1[k]/Conjugate[a1[Conjugate[k]]];
Gam[k_]:=-(-\[Lambda])*Conjugate[b1[-Conjugate[k]]]/a1[k]/delta1[k];*)

\[Theta][x_,t_][z_]:=2 I (2 t z^2+x z);
(*G1[x_,t_][z_]:=Inverse[(1	0
Gam[z]*Exp[\[Theta][x,t][z]]	1

)];*)
G1[x_,t_][z_]:=({
 {1, 0},
 {-Gam[z]*Exp[\[Theta][x,t][z]], 1}
});
G1[_,_][_?InfinityQ]:=({
 {1., 0},
 {0, 1.}
});
(*G3[x_,t_][z_]:=Inverse[(1	\[Lambda]*Conjugate[Gam[Conjugate[z]]]*Exp[-\[Theta][x,t][z]]
0	1

)];*)
G3[x_,t_][z_]:=({
 {1, -\[Lambda]*Conjugate[Gam[Conjugate[z]]]*Exp[-\[Theta][x,t][z]]},
 {0, 1}
});
G3[_,_][_?InfinityQ]:=({
 {1., 0},
 {0, 1.}
});
(*G4[x_,t_][z_]:=Inverse[(1	-gam[z]*Exp[-\[Theta][x,t][z]]
-\[Lambda]*Conjugate[gam[z]]*Exp[\[Theta][x,t][z]]	1+\[Lambda]*Abs[gam[z]]^2

)];*)
G4[x_,t_][z_]:=({
 {1+\[Lambda]*Conjugate[gam[Conjugate[z]]]*gam[z], gam[z]*Exp[-\[Theta][x,t][z]]},
 {\[Lambda]*Conjugate[gam[Conjugate[z]]]*Exp[\[Theta][x,t][z]], 1}
});
G4[_,_][_?InfinityQ]:=({
 {1., 0},
 {0, 1.}
});
(*G2[x_,t_][z_]:=G3[x,t][z].Inverse[G4[x,t][z]].G1[x,t][z];  (*wrong*)*) 
(*G2[x_,t_][z_]:=G1[x,t][z].Inverse[G4[x,t][z]].G3[x,t][z];  (*mine*)*)
G2[x_,t_][z_]:=\!\(\*
TagBox[
RowBox[{"(", "", GridBox[{
{"1", 
RowBox[{
RowBox[{"-", 
SuperscriptBox["E", 
RowBox[{"-", 
RowBox[{
RowBox[{"\[Theta]", "[", 
RowBox[{"x", ",", "t"}], "]"}], "[", "z", "]"}]}]]}], " ", 
RowBox[{"(", 
RowBox[{
RowBox[{"\[Lambda]", " ", 
RowBox[{"Conjugate", "[", 
RowBox[{"Gam", "[", 
RowBox[{"Conjugate", "[", "z", "]"}], "]"}], "]"}]}], "+", 
RowBox[{"gam", "[", "z", "]"}]}], ")"}]}]},
{
RowBox[{
RowBox[{"-", 
SuperscriptBox["E", 
RowBox[{
RowBox[{"\[Theta]", "[", 
RowBox[{"x", ",", "t"}], "]"}], "[", "z", "]"}]]}], " ", 
RowBox[{"(", 
RowBox[{
RowBox[{"\[Lambda]", " ", 
RowBox[{"Conjugate", "[", 
RowBox[{"gam", "[", 
RowBox[{"Conjugate", "[", "z", "]"}], "]"}], "]"}]}], "+", 
RowBox[{"Gam", "[", "z", "]"}]}], ")"}]}], 
RowBox[{"1", "+", 
RowBox[{
RowBox[{"(", 
RowBox[{
RowBox[{"\[Lambda]", " ", 
RowBox[{"Conjugate", "[", 
RowBox[{"Gam", "[", 
RowBox[{"Conjugate", "[", "z", "]"}], "]"}], "]"}]}], "+", 
RowBox[{"gam", "[", "z", "]"}]}], ")"}], "*", 
RowBox[{"(", 
RowBox[{
RowBox[{"\[Lambda]", " ", 
RowBox[{"Conjugate", "[", 
RowBox[{"gam", "[", 
RowBox[{"Conjugate", "[", "z", "]"}], "]"}], "]"}]}], "+", 
RowBox[{"Gam", "[", "z", "]"}]}], ")"}]}]}]}
},
GridBoxAlignment->{"Columns" -> {{Center}}, "ColumnsIndexed" -> {}, "Rows" -> {{Baseline}}, "RowsIndexed" -> {}, "Items" -> {}, "ItemsIndexed" -> {}},
GridBoxSpacings->{"Columns" -> {Offset[0.27999999999999997`], {Offset[0.7]}, Offset[0.27999999999999997`]}, "ColumnsIndexed" -> {}, "Rows" -> {Offset[0.2], {Offset[0.4]}, Offset[0.2]}, "RowsIndexed" -> {}, "Items" -> {}, "ItemsIndexed" -> {}}], "", ")"}],
Function[BoxForm`e$, MatrixForm[BoxForm`e$]]]\);
G2[_,_][_?InfinityQ]:=({
 {1., 0},
 {0, 1.}
});
(**)
Gamsamp[z_]:=rsamp[z];
gamsamp[z_]:=rsamp[z];
G1samp[x_,t_][z_]:=Inverse[({
 {1, 0},
 {Gamsamp[z]*Abs[Exp[\[Theta][x,t][z]]], 1}
})];
G1samp[_,_][_?InfinityQ]:=({
 {1., 0},
 {0, 1.}
});
G3samp[x_,t_][z_]:=Inverse[({
 {1, \[Lambda]*Conjugate[Gamsamp[Conjugate[z]]]*Abs[Exp[-\[Theta][x,t][z]]]},
 {0, 1}
})];
G3samp[_,_][_?InfinityQ]:=({
 {1., 0},
 {0, 1.}
});
G4samp[x_,t_][z_]:=Inverse[({
 {1, gamsamp[z]*Abs[Exp[-\[Theta][x,t][z]]]},
 {Conjugate[gamsamp[Conjugate[z]]]*Abs[Exp[\[Theta][x,t][z]]], 1+\[Lambda]*gamsamp[z]*Conjugate[gamsamp[Conjugate[z]]]}
})];
G4samp[_,_][_?InfinityQ]:=({
 {1., 0},
 {0, 1.}
});
G2samp[x_,t_][z_]:=Abs[G1samp[x,t][z]].Abs[Inverse[G4samp[x,t][z]]].Abs[G3samp[x,t][z]];  (*mine*)
G2samp[_,_][_?InfinityQ]:=({
 {1., 0},
 {0, 1.}
});
(**)
(*deform g4*)
M[x_,t_][z_]:=({
 {1, gam[z]*Exp[-\[Theta][x,t][z]]},
 {0, 1}
});
(*Mn[x_,t_][k_]:=(1	rb[k] Exp[-\[Theta][x,t][k]]
0	1

);*)
Msamp[x_,t_][z_]:=({
 {1, gamsamp[z] Exp[-\[Theta][x,t][z]]},
 {0, 1}
});
P[x_,t_][z_]:=({
 {1, 0},
 {\[Lambda]*Conjugate[gam[Conjugate[z]]]*Exp[\[Theta][x,t][z]], 1}
});
(*Pn[x_,t_][k_]:=(1	0
r[k] Exp[\[Theta][x,t][k]]	1

);*)
Psamp[x_,t_][z_]:=({
 {1, 0},
 {\[Lambda]*Conjugate[gamsamp[Conjugate[z]]]*Exp[\[Theta][x,t][z]], 1}
});
(**)

(*deform g2*)
\[Tau][z_]:=1+(\[Lambda] Conjugate[Gam[Conjugate[z]]]+gam[z])*(\[Lambda] Conjugate[gam[Conjugate[z]]]+Gam[z]);
\[Tau]samp[z_]:=1+(Abs[\[Lambda] Conjugate[Gamsamp[Conjugate[z]]]]+Abs[gamsamp[z]])*(Abs[\[Lambda] Conjugate[gamsamp[Conjugate[z]]]]+Abs[Gamsamp[z]]);

L[x_,t_][z_]:=({
 {1, 0},
 {-((\[Lambda] Conjugate[gam[Conjugate[z]]]+Gam[z]))/\[Tau][z]*Exp[\[Theta][x,t][z]], 1}
});
Lsamp[x_,t_][z_]:=({
 {1, 0},
 {-((Abs[\[Lambda] Conjugate[gamsamp[Conjugate[z]]]]+Abs[Gamsamp[z]]))/\[Tau]samp[z]*Exp[\[Theta][x,t][z]], 1}
});
U[x_,t_][z_]:=({
 {1, -(\[Lambda] Conjugate[Gam[Conjugate[z]]]+gam[z])/\[Tau][z]*Exp[-\[Theta][x,t][z]]},
 {0, 1}
});
Usamp[x_,t_][z_]:=({
 {1, -(Abs[\[Lambda] Conjugate[Gamsamp[Conjugate[z]]]]+Abs[gamsamp[z]])/\[Tau]samp[z]*Exp[-\[Theta][x,t][z]]},
 {0, 1}
});
DD[z_]:=({
 {1/\[Tau][z], 0},
 {0, \[Tau][z]}
});
DDsamp[z_]:=({
 {1/\[Tau]samp[z], 0},
 {0, \[Tau]samp[z]}
});


(* ::Input::Initialization:: *)
\[CapitalPhi]s[x_,t_][z_]:=\[CapitalPhi][z/Sqrt[t]-x/(4 t)];
\[CapitalPhi]ins[x_,t_][z_]:=\[CapitalPhi]in[z/Sqrt[t]-x/(4 t)]

r[z_]:=((\[Lambda] Conjugate[gam[Conjugate[z]]]+Gam[z]));
rs[x_,t_][z_]:=r[z/Sqrt[t]-x/(4 t)];
rssamp[x_,t_][z_]:=rsamp[z/Sqrt[t]-x/(4 t)];

\[Tau][z_]:=1+(\[Lambda] Conjugate[Gam[Conjugate[z]]]+gam[z])*(\[Lambda] Conjugate[gam[Conjugate[z]]]+Gam[z]);
\[Tau]samp[z_]:=1+(Abs[\[Lambda] Conjugate[Gamsamp[Conjugate[z]]]]+Abs[gamsamp[z]])*(Abs[\[Lambda] Conjugate[gamsamp[Conjugate[z]]]]+Abs[Gamsamp[z]]);
\[Tau]s[x_,t_][z_]:=\[Tau][z/Sqrt[t]-x/(4 t)];
\[Tau]ssamp[x_,t_][z_]:=\[Tau]samp[z/Sqrt[t]-x/(4 t)];

rb[k_]:=\[Lambda] cc[r[cc[k]]];
rbsamp=rsamp;
rsb[x_,t_][z_]:=rb[z/Sqrt[t]-x/(4 t)];
rsbsamp[x_,t_][z_]:=rbsamp[z/Sqrt[t]-x/(4 t)];

r4[z_]:=\[Lambda] cc[gam[cc[z]]];
r4b[z_]:=gam[z];
r4s[x_,t_][z_]:=r4[z/Sqrt[t]-x/(4 t)];
r4sb[x_,t_][z_]:=r4b[z/Sqrt[t]-x/(4 t)];

r4samp[z_]:=gamsamp[z];
r4ssamp[x_,t_][z_]:=r4samp[z/Sqrt[t]-x/(4 t)];
r4bsamp[k_]:=\[Lambda] cc[r4samp[cc[k]]];
r4sbsamp[x_,t_][z_]:=r4bsamp[z/Sqrt[t]-x/(4 t)];

\[CapitalPhi]ssamp[x_,t_][z_]:=\[CapitalPhi]samp[z/Sqrt[t]-x/(4 t)];
\[CapitalPhi]inssamp[x_,t_][z_]:=\[CapitalPhi]insamp[z/Sqrt[t]-x/(4 t)]
\[Theta]s[x_,t_][z_]:=-(I x^2)/(4 t)+4 I z^2

Ls[x_,t_][k_]:=({
 {1, 0},
 {rs[x,t][k]/\[Tau]s[x,t][k] Exp[\[Theta]s[x,t][k]], 1}
});
Lssamp[x_,t_][k_]:=({
 {1, 0},
 {rssamp[x,t][k]/\[Tau]ssamp[x,t][k] Exp[\[Theta]s[x,t][k]], 1}
});

Lins[x_,t_][k_]:=({
 {1, 0},
 {-rs[x,t][k]/\[Tau]s[x,t][k] Exp[\[Theta]s[x,t][k]], 1}
});
Linssamp[x_,t_][k_]:=({
 {1, 0},
 {-rssamp[x,t][k]/\[Tau]ssamp[x,t][k] Exp[\[Theta]s[x,t][k]], 1}
});

Us[x_,t_][k_]:=({
 {1, rsb[x,t][k]/\[Tau]s[x,t][k] Exp[-\[Theta]s[x,t][k]]},
 {0, 1}
});
Ussamp[x_,t_][k_]:=({
 {1, rsbsamp[x,t][k]/\[Tau]ssamp[x,t][k] Exp[-\[Theta]s[x,t][k]]},
 {0, 1}
});

Uins[x_,t_][k_]:=({
 {1, -rsb[x,t][k]/\[Tau]s[x,t][k] Exp[-\[Theta]s[x,t][k]]},
 {0, 1}
});
Uinssamp[x_,t_][k_]:=({
 {1, -rsbsamp[x,t][k]/\[Tau]ssamp[x,t][k] Exp[-\[Theta]s[x,t][k]]},
 {0, 1}
});

Ms[x_,t_][k_]:=({
 {1, r4sb[x,t][k] Exp[-\[Theta]s[x,t][k]]},
 {0, 1}
});
Mssamp[x_,t_][k_]:=({
 {1, r4sbsamp[x,t][k] Exp[-\[Theta]s[x,t][k]]},
 {0, 1}
});

Mis[x_,t_][k_]:=({
 {1, -r4sb[x,t][k] Exp[-\[Theta]s[x,t][k]]},
 {0, 1}
});
Missamp[x_,t_][k_]:=({
 {1, -r4sbsamp[x,t][k] Exp[-\[Theta]s[x,t][k]]},
 {0, 1}
});

Ps[x_,t_][k_]:=({
 {1, 0},
 {r4s[x,t][k] Exp[\[Theta]s[x,t][k]], 1}
});
Pssamp[x_,t_][k_]:=({
 {1, 0},
 {r4ssamp[x,t][k] Exp[\[Theta]s[x,t][k]], 1}
});

Pins[x_,t_][k_]:=({
 {1, 0},
 {-r4s[x,t][k] Exp[\[Theta]s[x,t][k]], 1}
});
Pinssamp[x_,t_][k_]:=({
 {1, 0},
 {-r4ssamp[x,t][k] Exp[\[Theta]s[x,t][k]], 1}
});


DDs[x_,t_][k_]:=({
 {\[Tau]s[x,t][k], 0},
 {0, 1/\[Tau]s[x,t][k]}
});
DDssamp[x_,t_][k_]:=({
 {\[Tau]ssamp[x,t][k], 0},
 {0, 1/\[Tau]ssamp[x,t][k]}
});

G1s[x_,t_][z_]:=({
 {1, 0},
 {Gam[z/Sqrt[t]-x/(4 t)]*Exp[\[Theta]s[x,t][z]], 1}
});
G1ssamp[x_,t_][z_]:=({
 {1, 0},
 {Gamsamp[z/Sqrt[t]-x/(4 t)]*Exp[\[Theta]s[x,t][z]], 1}
});

G3s[x_,t_][z_]:=({
 {1, \[Lambda]*Conjugate[Gam[Conjugate[(z/Sqrt[t]-x/(4 t))]]]*Exp[-\[Theta]s[x,t][z]]},
 {0, 1}
});
G3ssamp[x_,t_][z_]:=({
 {1, \[Lambda]*Conjugate[Gamsamp[Conjugate[(z/Sqrt[t]-x/(4 t))]]]*Exp[-\[Theta]s[x,t][z]]},
 {0, 1}
});

(*for pole calculation*)
qn[x_,t_][k_]:=Module[{out,i},
out = 1;
For[i=1,i<=Length[a],i++,
If[Abs[c[[i]]]Exp[Re[\[Theta][x,t][a[[i]]]]]>expconst,
out = out*(k-a[[i]])/(k-Conjugate[a[[i]]]);
];
];
out];
Qn[x_,t_][k_]:=({
 {qn[x,t][k], 0},
 {0, 1/qn[x,t][k]}
});
Qn[x_,t_][_?InfinityQ]:=({
 {1., 0},
 {0, 1.}
});



(* ::Input::Initialization:: *)
CME[x_]:=Chop[x,$MachineEpsilon];
ScatteringMatrixFiniteNLS[q_,n_,el_]:=Module[{qf,qfb,Dm,Dmb,IIm,IImb,P,Pb,id,Q,R,Qb,Rb,DM,DMb,q\[Sigma]1,q\[Sigma]1b,J\[Sigma]3,J\[Sigma]31,J\[Sigma]3b,J\[Sigma]31b,rhs,A,Ab},
       (*qf=Fun[q,Line[{-el,0}],n];*)
qfb=Fun[q,Line[{0,el}],n];
(*Print[{qf//Values//First//Abs,qf//DCTPlot}];*)
Print[{"q at right end point is ",qfb//Values//Last//Abs,"DCTPlot is ",qfb//DCTPlot}];
(*Dm=DerivativeMatrix[qf];*)
Dmb=DerivativeMatrix[qfb];
(*IIm=ReduceDimensionIntegrateMatrix[qf];*)
IImb=(ReduceDimensionIntegrateMatrix[(qfb//ReverseOrientation)]//Transpose//Reverse//Transpose//Reverse);
id=IdentityMatrix[n];
(*Q = DiagonalMatrix[qf//Values];
R= -\[Lambda] DiagonalMatrix[qf//Conjugate//Values];*)
Qb = DiagonalMatrix[qfb//Values];
Rb = (-\[Lambda]) DiagonalMatrix[qfb//Conjugate//Values];
(*A=BlockMatrix[{{id,-IIm.Q},{-IIm.R,id}}];*)
Ab=BlockMatrix[{{id,-IImb.Qb},{-IImb.Rb,id}}];
(*J\[Sigma]3=BlockMatrix[{{0*id,0},{0,-2I IIm}}];
J\[Sigma]31=BlockMatrix[{{2I IIm,0},{0,0*id}}];*)
J\[Sigma]3b=BlockMatrix[{{0*id,0},{0,-2I IImb}}];
J\[Sigma]31b=BlockMatrix[{{2I IImb,0},{0,0*id}}];
ScatteringMatrixFiniteNLS[qf,qfb,A,Ab,J\[Sigma]3,J\[Sigma]31,J\[Sigma]3b,J\[Sigma]31b,IIm,IImb]];
ScatteringMatrixFiniteNLS[qf_,qfb_,A_,Ab_,J\[Sigma]3_,J\[Sigma]31_,J\[Sigma]3b_,J\[Sigma]31b_,IIm_,IImb_][w_]:=Module[{ans0,ans1,rhs,lhs,n,s1,s2,qb,q,r,rb},
(*q = qf//Values;*)
qb = qfb//Values;
(*r = -\[Lambda] q//Conjugate;*)
rb=(-1)* (-\[Lambda] qb)//Conjugate;
n = qb//Length;

(*lhs=A+ w*J\[Sigma]3;
rhs = Join[ConstantArray[0.,n],IIm.r];
ans0 = LinearSolve[lhs//CME,rhs//CME];
(*Print["Linear solve 1 cond=",Max[SingularValueList[lhs,Tolerance\[Rule]0]]/Min[SingularValueList[lhs,Tolerance\[Rule]0]]];*)
lhs=A+w*J\[Sigma]31;
rhs=Join[IIm.q,ConstantArray[0.,n]];
ans1 = LinearSolve[lhs//CME,rhs//CME];
(*Print["Linear solve 2 cond=",Max[SingularValueList[lhs,Tolerance\[Rule]0]]/Min[SingularValueList[lhs,Tolerance\[Rule]0]]];
*)
s1={{ans0[[n]]+1,-ans1[[n]]},{ans0[[2n]],-ans1[[2n]]-1}};*)

lhs=Ab+ w*J\[Sigma]3b;
rhs = Join[ConstantArray[0.,n],IImb.rb];
ans0 = LinearSolve[lhs//CME,rhs//CME];
(*Print["Linear solve 3 cond=",Max[SingularValueList[lhs,Tolerance\[Rule]0]]/Min[SingularValueList[lhs,Tolerance\[Rule]0]]];
*)

lhs=Ab+ w*J\[Sigma]31b;
rhs = Join[IImb.qb,ConstantArray[0.,n]];
ans1 = LinearSolve[lhs//CME,rhs//CME];
(*Print["Linear solve 4 cond=",Max[SingularValueList[lhs,Tolerance\[Rule]0]]/Min[SingularValueList[lhs,Tolerance\[Rule]0]]];
*)
(*s2={{ans0[[1]]+1,ans1[[1]]},{ans0[[n+1]],ans1[[n+1]]+1}};*)
(*s1=Inverse[s2].s1*)
(*s1={{ans1[[n+1]]+1,0},{ans1[[1]],0}}??? test*)
s1={{ans1[[n+1]]+1,0},{ans1[[1]],0}}
];


(* ::Input::Initialization:: *)
ScatteringMatrixBFiniteNLS[g0_,g1_,n_,el_]:=Module[{g0fb,g1fb,Dm,Dmb,IIm,IImb,P,Pb,id,g0Qb,g02Qb,g1Qb,g0Rb,g1Rb,DM,DMb,q\[Sigma]1,q\[Sigma]1b,J\[Sigma]3,J\[Sigma]31,J\[Sigma]3b,J\[Sigma]31b,rhs,A0b,A1b,A2b,A3b},
       g0fb=Fun[g0,Line[{0,el}],n];
g1fb=Fun[g1,Line[{0,el}],n];
Print[{"g0 at right end point is ",g0fb//Values//Last//Abs,"DCTPlot is ",g0fb//DCTPlot}];
(*IIm=ReduceDimensionIntegrateMatrix[qf];*)
IImb=(ReduceDimensionIntegrateMatrix[(g0fb//ReverseOrientation)]//Transpose//Reverse//Transpose//Reverse);
id=IdentityMatrix[n];
(*Q = DiagonalMatrix[qf//Values];
R= -\[Lambda] DiagonalMatrix[qf//Conjugate//Values];*)
g0Qb = DiagonalMatrix[g0fb//Values];
g02Qb = DiagonalMatrix[Abs[g0fb//Values]^2];
g0Rb = (-\[Lambda]) DiagonalMatrix[g0fb//Conjugate//Values];
g1Qb = DiagonalMatrix[g1fb//Values];
g1Rb = (-\[Lambda]) DiagonalMatrix[g1fb//Conjugate//Values];
(*A=BlockMatrix[{{id,-IIm.Q},{-IIm.R,id}}];*)
A0b=BlockMatrix[{{id,id*0},{id*0,id}}];
A1b=BlockMatrix[{{id*0,IImb.g0Qb},{IImb.g0Rb,id*0}}];
A2b=BlockMatrix[{{id*0,-IImb.g1Qb},{IImb.g1Rb,id*0}}];
A3b=BlockMatrix[{{IImb.g02Qb,id*0},{id*0,-IImb.g02Qb}}];
J\[Sigma]31b=BlockMatrix[{{4I IImb,0},{0,0*id}}];
ScatteringMatrixFiniteNLS[g0fb,g1fb,A0b,A1b,A2b,A3b,J\[Sigma]3,J\[Sigma]31,J\[Sigma]3b,J\[Sigma]31b,IIm,IImb]];
ScatteringMatrixFiniteNLS[g0fb_,g1fb_,A0b_,A1b_,A2b_,A3b_,J\[Sigma]3_,J\[Sigma]31_,J\[Sigma]3b_,J\[Sigma]31b_,IIm_,IImb_][w_]:=Module[{ans0,ans1,rhs,lhs,n,s1,s2,qt1b,qt2b,r,rb},
(*q = qf//Values;*)
qt1b =( 2*w*g0fb+I*g1fb)//Values;
qt2b = (I*(-\[Lambda])*Abs[g0fb]^2)//Values;
(*r = -\[Lambda] q//Conjugate;*)
(*rb=(-1)* (-\[Lambda] qb)//Conjugate;*)
n = qt1b//Length;

lhs=A0b+(w^2)*J\[Sigma]31b-2*w*A1b+I*A2b+I* (-\[Lambda])*A3b;
rhs = Join[IImb.qt1b,IImb.qt2b];
ans1 = LinearSolve[lhs//CME,rhs//CME];
(*Print["Linear solve 4 cond=",Max[SingularValueList[lhs,Tolerance\[Rule]0]]/Min[SingularValueList[lhs,Tolerance\[Rule]0]]];
Print[ans1]*)
(*s2={{ans0[[1]]+1,ans1[[1]]},{ans0[[n+1]],ans1[[n+1]]+1}};*)
(*s1=Inverse[s2].s1*)
(*s1={{ans1[[n+1]]+1,0},{ans1[[1]],0}}??? test*)
s1={{ans1[[n+1]]+1,0},{ans1[[1]],0}}
];


(* ::Input::Initialization:: *)
HillNLS[F_,n_]:=Module[{c2,c1,c0,f11,f12,zz,f02,f01,t,A,mu,L,P,fun},
mu = .25;
L = Pi;
P =1;
f11[x_]:= 2I Cos[x/2]^2;
f12[x_]:=-2I Cos[x/2]^2;
zz[x_]:=ConstantArray[0.,Length[x]];
t[x_] := Tan[x/2];   (* *)
f02[x_]:= -I F[t[x]];
f01[x_]:=-\[Lambda] I Conjugate[F[t[x]]];
fun= {{{zz,f11},{f02,zz}},{{f01,zz},{zz,f12}}};
A= Hill[mu,L,n,P,fun];
Eigenvalues[Chop[A,$MachineEpsilon]]
];
LocatePolesNLS[F_,n_]:=Module[{eval,s,i,sys,vecs},
Off[General::unfl];
eval=HillNLS[F,n];
s = {};
For[i=1,i<=Length[eval],i++,
If[Im[eval[[i]]]>10^(-4)&& Abs[eval[[i]]]<30,  (*why this condition, looking for non real eigen value*)
s=Join[s,{eval[[i]]}];
];
];
On[General::unfl];
Chop[s,$MachineEpsilon]
];


(* ::Input::Initialization:: *)
J[0][x_,t_]:={{G1[x,t][#]&,G2[x,t][#]&,G3[x,t][#]&,G4[x,t][#]&},{Line[{el*I,0}],Line[{0,-el}],Line[{-el*I,0}],Line[{0,el}]},{bigN,bigN,bigN,bigN}};
Jsamp[0][x_,t_]:={{G1samp[x,t][#]&,G2samp[x,t][#]&,G3samp[x,t][#]&,G4samp[x,t][#]&},{Line[{el*I,0}],Line[{0,-el}],Line[{-el*I,0}],Line[{0,el}]},{bigN,bigN,bigN,bigN}};
Jadapt[0][x_,t_]:=Adapt[Jsamp[0][x,t],globalTol][J[0][x,t]];
(*Jadapt[0][x_,t_]:=J[0][x,t];*)


(* ::Input::Initialization:: *)
gam0[k_]:=q00/2/I/(k-(1+2I));(*1+2I works amazingly as it cancels exactly*)
Gam0[k_]:=\[Lambda] Conjugate[q00]/2/I/(k-(1-2I));
gamb0[k_]:=\[Lambda] cc[gam0[cc[k]]];
Gamb0[k_]:=\[Lambda] cc[Gam0[cc[k]]];
gamb[k_]:=\[Lambda]*Conjugate[gam[Conjugate[k]]];
Gamb[k_]:=\[Lambda]*Conjugate[Gam[Conjugate[k]]];

G4a[x_,t_][k_]:=({
 {1+(gam[k]-gam0[k])*(gamb[k]-gamb0[k]), (gam[k]-gam0[k])*Exp[-\[Theta][x,t][k]]},
 {(gamb[k]-gamb0[k])*Exp[\[Theta][x,t][k]], 1}
});
G4a[_,_][_?InfinityQ]:=({
 {1., 0},
 {0, 1.}
});
G1a[x_,t_][k_]:=({
 {1, 0},
 {-(Gam[k]-Gam0[k])*Exp[\[Theta][x,t][k]], 1}
});
G1a[_,_][_?InfinityQ]:=({
 {1., 0},
 {0, 1.}
});
G3a[x_,t_][k_]:=({
 {1, -(Gamb[k]-Gamb0[k])*Exp[-\[Theta][x,t][k]]},
 {0, 1}
});
G3a[_,_][_?InfinityQ]:=({
 {1., 0},
 {0, 1.}
});
G2a[x_,t_][k_]:=\!\(\*
TagBox[
RowBox[{"(", "", GridBox[{
{"1", 
RowBox[{
RowBox[{"-", 
SuperscriptBox["E", 
RowBox[{"-", 
RowBox[{
RowBox[{"\[Theta]", "[", 
RowBox[{"x", ",", "t"}], "]"}], "[", "k", "]"}]}]]}], " ", 
RowBox[{"(", 
RowBox[{
RowBox[{"Gamb", "[", "k", "]"}], "+", 
RowBox[{"gam", "[", "k", "]"}]}], ")"}]}]},
{
RowBox[{
RowBox[{"-", 
SuperscriptBox["E", 
RowBox[{
RowBox[{"\[Theta]", "[", 
RowBox[{"x", ",", "t"}], "]"}], "[", "k", "]"}]]}], " ", 
RowBox[{"(", 
RowBox[{
RowBox[{"gamb", "[", "k", "]"}], "+", 
RowBox[{"Gam", "[", "k", "]"}]}], ")"}]}], 
RowBox[{"1", "+", 
RowBox[{
RowBox[{"(", 
RowBox[{
RowBox[{"Gamb", "[", "k", "]"}], "+", 
RowBox[{"gam", "[", "k", "]"}]}], ")"}], "*", 
RowBox[{"(", 
RowBox[{
RowBox[{"gamb", "[", "k", "]"}], "+", 
RowBox[{"Gam", "[", "k", "]"}]}], ")"}]}]}]}
},
GridBoxAlignment->{"Columns" -> {{Center}}, "ColumnsIndexed" -> {}, "Rows" -> {{Baseline}}, "RowsIndexed" -> {}, "Items" -> {}, "ItemsIndexed" -> {}},
GridBoxSpacings->{"Columns" -> {Offset[0.27999999999999997`], {Offset[0.7]}, Offset[0.27999999999999997`]}, "ColumnsIndexed" -> {}, "Rows" -> {Offset[0.2], {Offset[0.4]}, Offset[0.2]}, "RowsIndexed" -> {}, "Items" -> {}, "ItemsIndexed" -> {}}], "", ")"}],
Function[BoxForm`e$, MatrixForm[BoxForm`e$]]]\);
G2a[_,_][_?InfinityQ]:=({
 {1., 0},
 {0, 1.}
});
J[3][x_,t_]:={{G1a[x,t][#]&,G2a[x,t][#]&,G3a[x,t][#]&,G4a[x,t][#]&},{Line[{el*I,0}],Line[{0,-el}],Line[{-el*I,0}],Line[{0,2*el}]},{bigN,2*bigN,bigN,4*bigN}};
Jsamp[3][x_,t_]:={{G1samp[x,t][#]&,G2samp[x,t][#]&,G3samp[x,t][#]&,G4samp[x,t][#]&},{Line[{el*I,0}],Line[{0,-el}],Line[{-el*I,0}],Line[{0,2*el}]},{bigN,2*bigN,bigN,4*bigN}};
Jadapt[3][x_,t_]:=Adapt[Jsamp[3][x,t],globalTol][J[3][x,t]];
(*Jadapt[0][x_,t_]:=J[0][x,t];*)


(* ::Input::Initialization:: *)
(*SmallTimeContour={Line[{-el + I \[Nu],Sqrt[2]\[Nu] Exp[I 3 Pi/4]}],Line[{Sqrt[2]\[Nu] Exp[I 3 Pi/4],0}],
Line[{-el,0}],
Line[{-el - I \[Nu],Sqrt[2]\[Nu] Exp[I 5 Pi/4]}],
Line[{Sqrt[2]\[Nu] Exp[I 5 Pi/4],0}],
Line[{0,Sqrt[2]\[Nu] Exp[I Pi/4]}],
Line[{Sqrt[2]\[Nu] Exp[I Pi/4],I \[Nu] + el}],
Line[{0,Sqrt[2]\[Nu] Exp[-I Pi/4]}],
Line[{Sqrt[2]\[Nu] Exp[-I Pi/4],-I \[Nu] + el}]};
Modk0[x_,t_]:=If[t < 10*$MachineEpsilon,-Sign[x]*100,-Sign[x]*Min[Abs[x/(4t)],100]];*)


(* ::Input::Initialization:: *)
(*J[1][x_,t_]:={{Un[x,t][#]&,Un[x,t][#]&,
DDn[#]&,Ln[x,t][#]&,Ln[x,t][#]&,Pn[x,t][#]&,Pn[x,t][#]&,Mn[x,t][#]&,Mn[x,t][#]&}, SmallTimeContour + Modk0[x,t], {bigN,smallN,bigN,bigN,smallN,smallN,bigN,smallN,bigN}};
Jsamp[1][x_,t_]:={{Unsamp[x,t][#]&,Unsamp[x,t][#]&,
DDnsamp[#]&,Lnsamp[x,t][#]&,Lnsamp[x,t][#]&,Pnsamp[x,t][#]&,Pnsamp[x,t][#]&,Mnsamp[x,t][#]&,Mnsamp[x,t][#]&}, SmallTimeContour + Modk0[x,t],{bigN,smallN,bigN,bigN,smallN,smallN,bigN,smallN,bigN}};
Jadapt[1][x_,t_]:=Adapt[Jsamp[1][x,t],globalTol][J[1][x,t]]*)


(* ::Input::Initialization:: *)
(*s0[x_,t_]:=N[If[Abs[t]<0.0001,-el,-Min[x/4/t,el]]];this is prob not good*)
s0[x_,t_]:=-x/4/t;
J[1][x_,t_]:={{G1[x,t][#]&,G1[x,t][#]&,L[x,t][#]&,L[x,t][#]&,DD[#]&,U[x,t][#]&,U[x,t][#]&,G3[x,t][#]&,G3[x,t][#]&},
{Line[{\[Nu]*Exp[I*Pi/4]+I*Abs[s0[x,t]]+I*el,\[Nu]*Exp[I*Pi/4]+I*Abs[s0[x,t]]}],
Line[{\[Nu]*Exp[I*Pi/4]+I*Abs[s0[x,t]],s0[x,t]}],
Line[{0+s0[x,t],Exp[-I*3*Pi/4]*\[Nu]+s0[x,t]}],Line[{Exp[-3I*Pi/4]*\[Nu]+s0[x,t],Exp[-I*3*Pi/4]*\[Nu]+s0[x,t]-el}],
Line[{0+s0[x,t],-el+s0[x,t]}],
Line[{0+s0[x,t],Exp[I*3*Pi/4]*\[Nu]+s0[x,t]}],Line[{Exp[I*3*Pi/4]*\[Nu]+s0[x,t],Exp[I*3*Pi/4]*\[Nu]+s0[x,t]-el}],
(*G3*)
Line[{\[Nu]*Exp[-I*Pi/4]-I*Abs[s0[x,t]]-I*el,\[Nu]*Exp[-I*Pi/4]-I*Abs[s0[x,t]]}],
Line[{\[Nu]*Exp[-I*Pi/4]-I*Abs[s0[x,t]],s0[x,t]}]},{bigN,bigN,bigN,bigN,bigN*4,bigN,bigN,bigN,bigN}};
Jsamp[1][x_,t_]:={{G1samp[x,t][#]&,G1samp[x,t][#]&,Lsamp[x,t][#]&,Lsamp[x,t][#]&,DDsamp[#]&,Usamp[x,t][#]&,Usamp[x,t][#]&,G3samp[x,t][#]&,G3samp[x,t][#]&},
{Line[{\[Nu]*Exp[I*Pi/4]+I*Abs[s0[x,t]]+I*el,\[Nu]*Exp[I*Pi/4]+I*Abs[s0[x,t]]}],
Line[{\[Nu]*Exp[I*Pi/4]+I*Abs[s0[x,t]],s0[x,t]}],
Line[{0+s0[x,t],Exp[-I*3*Pi/4]*\[Nu]+s0[x,t]}],Line[{Exp[-3I*Pi/4]*\[Nu]+s0[x,t],Exp[-I*3*Pi/4]*\[Nu]+s0[x,t]-el}],
Line[{0+s0[x,t],-el+s0[x,t]}],
Line[{0+s0[x,t],Exp[I*3*Pi/4]*\[Nu]+s0[x,t]}],Line[{Exp[I*3*Pi/4]*\[Nu]+s0[x,t],Exp[I*3*Pi/4]*\[Nu]+s0[x,t]-el}],
(*G3*)
Line[{\[Nu]*Exp[-I*Pi/4]-I*Abs[s0[x,t]]-I*el,\[Nu]*Exp[-I*Pi/4]-I*Abs[s0[x,t]]}],
Line[{\[Nu]*Exp[-I*Pi/4]-I*Abs[s0[x,t]],s0[x,t]}]},{bigN,bigN,bigN,bigN,bigN*4,bigN,bigN,bigN,bigN}};
Jadapt[1][x_,t_]:=Adapt[Jsamp[1][x,t],globalTol][J[1][x,t]];


(* ::Input::Initialization:: *)
DDI[x_,t_][k_]:=If[Im[k] >=0,DDs[x,t][k],IdentityMatrix[2]]; (*used for lensing*)
\[Tau][k_]:=1+(\[Lambda] cc[gam[cc[k]]]+Gam[k])*(\[Lambda] cc[Gam[cc[k]]]+gam[k]);
startift[]:=Module[{},
Clear[ift];
dom=Truncate[globalTol][{Log[\[Tau][#]]&,Line[{-el,el}],50}][[1]];
(*Print["this is dom",dom];*)
If [dom=={}[[1]],ift[k0_]:=Fun[0*#&,{-el,k0}//Line,50];,
ift[k0_]:=ift[k0]=Fun[Log[\[Tau][#]]&,{LeftEndpoint[dom],k0}//Line,50];];
];
\[Delta]t[x_,t_][s_,k_]:=(Cauchy[s,ift[-x/(4 t)],k]//Exp);
\[Delta]t[x_,t_][k_]:=(Cauchy[ift[-x/(4 t)],k]//Exp);
\[CapitalPhi]t[x_,t_][z__]:=({
 {\[Delta]t[x,t][z], 0},
 {0, 1/\[Delta]t[x,t][z]}
});
\[CapitalPhi]tin[t__][z__]:=({
 {1/\[Delta]t[t][z], 0},
 {0, \[Delta]t[t][z]}
});
\[CapitalPhi]ts[x_,t_][z_]:=\[CapitalPhi]t[x,t][z/Sqrt[t]-x/(4 t)];
\[CapitalPhi]tins[x_,t_][z_]:=\[CapitalPhi]tin[x,t][z/Sqrt[t]-x/(4 t)];
MaxRads[x_,t_]:={Min[Sqrt[2]\[Nu] *Sqrt[t],100],Min[Sqrt[2]\[Nu] *Sqrt[t]/2,1]};
J[2][x_,t_]:=Module[{Jumps,Domains,NumPts},
Jumps={
\[CapitalPhi]ts[x,t][#].Ls[x,t][#].\[CapitalPhi]tins[x,t][#]&,
\[CapitalPhi]ts[x,t][#].Ls[x,t][#].\[CapitalPhi]tins[x,t][#]&,
\[CapitalPhi]ts[x,t][#].Us[x,t][#].\[CapitalPhi]tins[x,t][#]&,
\[CapitalPhi]ts[x,t][#].Us[x,t][#].\[CapitalPhi]tins[x,t][#]&,
\[CapitalPhi]ts[x,t][#].G3s[x,t][#].Ms[x,t][#].\[CapitalPhi]tins[x,t][#]&,
\[CapitalPhi]ts[x,t][#].Ms[x,t][#].\[CapitalPhi]tins[x,t][#]&,
\[CapitalPhi]ts[x,t][#].Ps[x,t][#].G1s[x,t][#].\[CapitalPhi]tins[x,t][#]&,
\[CapitalPhi]ts[x,t][#].Ps[x,t][#].\[CapitalPhi]tins[x,t][#]&,
DDI[x,t][#].\[CapitalPhi]tins[x,t][#]&,
DDs[x,t][#].Us[x,t][#].\[CapitalPhi]tins[x,t][#]&,
Lins[x,t][#].G3s[x,t][#].Ms[x,t][#].\[CapitalPhi]tins[x,t][#]&,
Lins[x,t][#].\[CapitalPhi]tins[x,t][#]&,
\[CapitalPhi]ts[x,t][#].G1s[x,t][#].\[CapitalPhi]tins[x,t][#]&,
\[CapitalPhi]ts[x,t][#].G3s[x,t][#].\[CapitalPhi]tins[x,t][#]&
};
Domains={
Line[{-el Sqrt[t] - I \[Nu] Sqrt[t],MaxRads[x,t][[1]]Exp[-3I \[Pi]/4.]}],
Line[MaxRads[x,t]Exp[-3I \[Pi]/4.]],
Line[{-el Sqrt[t] + I \[Nu] Sqrt[t],MaxRads[x,t][[1]]Exp[3I \[Pi]/4.]}],
Line[MaxRads[x,t]Exp[3I \[Pi]/4.]],
Line[{Reverse[MaxRads[x,t]][[1]]Exp[-I \[Pi]/4.],Reverse[MaxRads[x,t]][[2]]Exp[-I \[Pi]/4.]*2}],
Line[{MaxRads[x,t][[1]]Exp[-I \[Pi]/4.]*2,el Sqrt[t] -2 I \[Nu] Sqrt[t]}],
Line[{Reverse[MaxRads[x,t]][[1]]Exp[I \[Pi]/4.],Reverse[MaxRads[x,t]][[2]]Exp[I \[Pi]/4.]*2}],
Line[{MaxRads[x,t][[1]]Exp[I \[Pi]/4.]*2,el Sqrt[t] +2 I \[Nu] Sqrt[t]}],
Line[{Exp[-3I \[Pi]/4],Exp[3I \[Pi]/4]}*MaxRads[x,t][[2]]],
Line[{Exp[3I \[Pi]/4],Exp[I \[Pi]/4]}*MaxRads[x,t][[2]]],
Line[{Exp[I \[Pi]/4],Exp[- I \[Pi]/4]}*MaxRads[x,t][[2]]],
Line[{Exp[-I \[Pi]/4],Exp[-3 I \[Pi]/4]}*MaxRads[x,t][[2]]],
(*Line[{MaxRads[x,t][[1]]Exp[I \[Pi]/4.],2*\[Nu]*Sqrt[2]*(Exp[I \[Pi]/4.])}],*)
Line[{2*\[Nu]*Sqrt[2]*(Exp[I \[Pi]/4.]),2*\[Nu]*Sqrt[2]*(Exp[I \[Pi]/4.])+I*el}],
(*Line[{MaxRads[x,t][[1]]Exp[-I \[Pi]/4.],2*\[Nu]*Sqrt[2]*(Exp[-I \[Pi]/4.])}],*)
Line[{2*\[Nu]*Sqrt[2]*(Exp[-I \[Pi]/4.]),2*\[Nu]*(Exp[-I \[Pi]/4.])-I*el}]
};
NumPts=Table[smallN,{i,1,14}];
NumPts[[1]]=bigN;
NumPts[[3]]=bigN;
NumPts[[6]]=bigN;
NumPts[[8]]=bigN;
NumPts[[13]]=bigN;
NumPts[[14]]=bigN;
{Jumps,Domains,NumPts}
];
Jsamp[2][x_,t_]:=Module[{Jumps,Domains,NumPts},
Jumps={
Lssamp[x,t][#]&,
Lssamp[x,t][#]&,
Ussamp[x,t][#]&,
Ussamp[x,t][#]&,
G3ssamp[x,t][#].Mssamp[x,t][#]&,
Mssamp[x,t][#]&,
Pssamp[x,t][#].G1ssamp[x,t][#]&,
Pssamp[x,t][#]&,
DDssamp[x,t][#]&,
DDssamp[x,t][#].Ussamp[x,t][#]&,
Linssamp[x,t][#].G3ssamp[x,t][#].Mssamp[x,t][#]&,
Linssamp[x,t][#]&,
G1ssamp[x,t][#]&,
G3ssamp[x,t][#]&};
Domains={
Line[{-el Sqrt[t] - I \[Nu] Sqrt[t],MaxRads[x,t][[1]]Exp[-3I \[Pi]/4.]}],
Line[MaxRads[x,t]Exp[-3I \[Pi]/4.]],
Line[{-el Sqrt[t] + I \[Nu] Sqrt[t],MaxRads[x,t][[1]]Exp[3I \[Pi]/4.]}],
Line[MaxRads[x,t]Exp[3I \[Pi]/4.]],
Line[{Reverse[MaxRads[x,t]][[1]]Exp[-I \[Pi]/4.],Reverse[MaxRads[x,t]][[2]]Exp[-I \[Pi]/4.]*2}],
Line[{MaxRads[x,t][[1]]Exp[-I \[Pi]/4.]*2,el Sqrt[t] -2 I \[Nu] Sqrt[t]}],
Line[{Reverse[MaxRads[x,t]][[1]]Exp[I \[Pi]/4.],Reverse[MaxRads[x,t]][[2]]Exp[I \[Pi]/4.]*2}],
Line[{MaxRads[x,t][[1]]Exp[I \[Pi]/4.]*2,el Sqrt[t] +2 I \[Nu] Sqrt[t]}],
Line[{Exp[-3I \[Pi]/4],Exp[3I \[Pi]/4]}*MaxRads[x,t][[2]]],
Line[{Exp[3I \[Pi]/4],Exp[I \[Pi]/4]}*MaxRads[x,t][[2]]],
Line[{Exp[I \[Pi]/4],Exp[- I \[Pi]/4]}*MaxRads[x,t][[2]]],
Line[{Exp[-I \[Pi]/4],Exp[-3 I \[Pi]/4]}*MaxRads[x,t][[2]]],
(*Line[{MaxRads[x,t][[1]]Exp[I \[Pi]/4.],2*\[Nu]*Sqrt[2]*(Exp[I \[Pi]/4.])}],*)
Line[{2*\[Nu]*Sqrt[2]*(Exp[I \[Pi]/4.]),2*\[Nu]*Sqrt[2]*(Exp[I \[Pi]/4.])+I*el}],
(*Line[{MaxRads[x,t][[1]]Exp[-I \[Pi]/4.],2*\[Nu]*Sqrt[2]*(Exp[-I \[Pi]/4.])}],*)
Line[{2*\[Nu]*Sqrt[2]*(Exp[-I \[Pi]/4.]),2*\[Nu]*(Exp[-I \[Pi]/4.])-I*el}]
};
NumPts=Table[smallN,{i,1,14}];
NumPts[[1]]=bigN;
NumPts[[3]]=bigN;
NumPts[[6]]=bigN;
NumPts[[8]]=bigN;
NumPts[[13]]=bigN;
NumPts[[14]]=bigN;
{Jumps,Domains,NumPts}
];
Jadapt[2][x_,t_]:=Adapt[Jsamp[2][x,t],globalTol][J[2][x,t]];


(* ::Input::Initialization:: *)
InvScale[x_,t_][k_]:=Sqrt[t](k+x/(4t));
Scaling[x_,t_][k_]:=k/Sqrt[t] -x/(4t);
Tn[+1][x_,t_,a_,c_][z_]:=({
 {1, 0},
 {-c Exp[\[Theta][x,t][a]]/(z-a), 1}
});
Tn[-1][x_,t_,a_,c_][z_]:=({
 {1, \[Lambda] cc[-c Exp[\[Theta][x,t][a]]/(cc[z]-a)]},
 { 0, 1}
});
Sn[+1][x_,t_,a_,c_][z_]:=({
 {1, -(z-a)/c*Exp[-\[Theta][x,t][a]]},
 {0, 1}
});
Sn[-1][x_,t_,a_,c_][z_]:=({
 {1, 0},
 {\[Lambda] cc[-(cc[z]-a)/c*Exp[-\[Theta][x,t][a]]], 1}
});
(*  a center   r  radius, +1 is in upper -1 is in lower *)
ContourArrayn[+1,r_,a_]:={Arc[a,r,{0,Pi}],Arc[a,r,{Pi,2Pi}]};
ContourArrayn[-1,r_,a_]:={Arc[a//cc,r,{0,-Pi}],Arc[a//cc,r,{-Pi,-2Pi}]};

T[+1][x_,t_,a_,c_][z_]:=Tn[+1][x,t,a,c][Scaling[x,t][z]];
T[-1][x_,t_,a_,c_][z_]:=Tn[-1][x,t,a,c][Scaling[x,t][z]];
S[+1][x_,t_,a_,c_][z_]:=Sn[+1][x,t,a,c][Scaling[x,t][z]];
S[-1][x_,t_,a_,c_][z_]:=Sn[-1][x,t,a,c][Scaling[x,t][z]];


(* ::Input::Initialization:: *)
ContourArray[+1,r_,a_,x_,t_]:={Arc[InvScale[x,t][a],r*Sqrt[t],{0,Pi}],Arc[InvScale[x,t][a],r*Sqrt[t],{Pi,2Pi}]};
ContourArray[-1,r_,a_,x_,t_]:={Arc[InvScale[x,t][a//cc],r*Sqrt[t],{0,-Pi}],Arc[InvScale[x,t][a//cc],r*Sqrt[t],{-Pi,-2Pi}]};

PoleListn[x_,t_]:=Module[{out,i,Domain,Jumps,Points},
Domain={};
Jumps={};
Points={};
For[i=1,i<=Length[a],i++,
If[1/globalTol>Abs[c[[i]]]Exp[Re[\[Theta][x,t][a[[i]]]]]&&Abs[c[[i]]]Exp[Re[\[Theta][x,t][a[[i]]]]]> globalTol,
If[Abs[c[[i]]]Exp[Re[\[Theta][x,t][a[[i]]]]]>expconst,
Jumps=Join[Jumps,{Sn[+1][x,t,a[[i]],c[[i]]],Sn[+1][x,t,a[[i]],c[[i]]]}];
Jumps=Join[Jumps,{Sn[-1][x,t,a[[i]],c[[i]]],Sn[-1][x,t,a[[i]],c[[i]]]}];
flag="pos";,
Jumps = Join[Jumps,{Tn[+1][x,t,a[[i]],c[[i]]],Tn[+1][x,t,a[[i]],c[[i]]]}];
Jumps = Join[Jumps,{Tn[-1][x,t,a[[i]],c[[i]]],Tn[-1][x,t,a[[i]],c[[i]]]}];
flag="neg";
];
Domain= Join[Domain,Join[ContourArrayn[+1,rad,a[[i]]],ContourArrayn[-1,rad,a[[i]]]]];
Points=Join[Points,{smallN,smallN,smallN,smallN}];
];
];
{Jumps,Domain,Points}
];
PoleList[x_,t_]:=Module[{out,i,Domain,Jumps,Points},
Domain={};
Jumps={};
Points={};
For[i=1,i<=Length[a],i++,
If[1/tol >Abs[c[[i]]]Exp[Re[\[Theta][x,t][a[[i]]]]]> tol,
If[Abs[c[[i]]]Exp[Re[\[Theta][x,t][a[[i]]]]]>expconst,
Jumps=Join[Jumps,{S[+1][x,t,a[[i]],c[[i]]],Sn[+1][x,t,a[[i]],c[[i]]]}];
Jumps=Join[Jumps,{S[-1][x,t,a[[i]],c[[i]]],Sn[-1][x,t,a[[i]],c[[i]]]}];
flag="pos";,
Jumps = Join[Jumps,{T[+1][x,t,a[[i]],c[[i]]],Tn[+1][x,t,a[[i]],c[[i]]]}];
Jumps = Join[Jumps,{T[-1][x,t,a[[i]],c[[i]]],Tn[-1][x,t,a[[i]],c[[i]]]}];
flag="neg";
];
Domain= Join[Domain,Join[ContourArray[+1,rad,a[[i]]],ContourArray[-1,rad,a[[i]]]]];
Points=Join[Points,{smallN,smallN,smallN,smallN}];
];
];
{Jumps,Domain,Points}
];


(* ::Input::Initialization:: *)
DomainIntegrate[0.]:=0;
tcrit=8;
NLS[i_][x_,t_]:=Module[{scale,\[CapitalPhi]1,\[CapitalPhi]2,\[CapitalPhi],out,t1,t2,t3,t4,poles},
If[i==2,scale=True,scale=False];
RHSolved//Clear;
RHSolved[X_]:=RHSolved[X]=RHSolve[X];
RHSolved[{}]:=0.;
RHSolution[X_][z_]:=Cauchy[X//RHSolved,z]+IdentityMatrix[2];

If[scale,
t1=Timing[rhp1=ConjugateList[Jadapt[i][x,t],Q[x,t]]//MakeListFun;];
t2=Timing[RHSolved[rhp1];];
\[CapitalPhi]1[k_]:=RHSolution[rhp1][InvScale[x,t][k]]//Inverse;,
t1=Timing[rhp1=ConjugateList[Jadapt[i][x,t],Qn[x,t]]//MakeListFun;];
t2=Timing[RHSolved[rhp1];];
\[CapitalPhi]1[k_]:=RHSolution[rhp1][k]//Inverse;
];
domainOutput = DomainPlot[rhp1];

rhp2= ConjugateList[PoleListn[x,t],Qn[x,t]];(*no scale, nah, looks like pole contours are all not scaled*)
If[i==2,
rhp2= ConjugateList[rhp2,\[CapitalPhi]tin[x,t]];                   (* scale, nah this is not scale but remove the contour on the negative real*)
];
t3=Timing[rhp2= ConjugateList[rhp2,\[CapitalPhi]1]//MakeListFun;];
t4=Timing[RHSolved[rhp2];];
\[CapitalPhi]2 = RHSolution[rhp2];
\[CapitalPhi][k_]:=RHSolution[rhp2][k].RHSolution[rhp1][k];
out=-(DomainIntegrate[RHSolved[rhp1]] If[scale,1/Sqrt[t],1]+DomainIntegrate[RHSolved[rhp2]])[[1,2]]/Pi;
(*out=-(DomainIntegrate[RHSolved[rhp1]] If[scale,1/Sqrt[t],1])[[1,2]]/Pi;*)
timestring= "Region: " <>ToString[i]<>" ("<>ToString[x]<>","<>ToString[t]<>") "<>"1) Construct: " <> ToString[t1//First]<>"  "<>"1) Solve: " <> ToString[t2//First]<>"  "<>"2) Construct: " <> ToString[t3//First]<>"  "<>"2) Solve: " <> ToString[t4//First];
If[timeflag,Print[timestring];];
{out,\[CapitalPhi],rhp1,rhp2,timestring}
];
NLSAuto[x_,t_]:=\[Piecewise]{
 {NLS[0][x,t][[1]], Abs[x]<1&&t<.1},
 {NLS[1][x,t][[1]], t>tcrit},
 {NLS[1][x,t][[1]], True}
}



(* ::Input::Initialization:: *)
(*NLS[x_,t_]:=-DomainIntegrate[RHSolveTop[JNLS[x,t]]]\[LeftDoubleBracket]2\[RightDoubleBracket]/( \[Pi]\[NonBreakingSpace])*If[t>tcrit,1/Sqrt[t],1];
NLSSelect[i_][x_,t_]:=-DomainIntegrate[RHSolveTop[G[i][x,t]]]\[LeftDoubleBracket]2\[RightDoubleBracket]/( \[Pi]\[NonBreakingSpace])*If[i\[Equal]2,1/Sqrt[t],1];*)


(* ::Input::Initialization:: *)
End[];
